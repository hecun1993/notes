`秒杀的难点在于如何高效的处理竞争`

秒杀系统的业务流程:
    核心: 是对库存的分析
    商家 添加/调整 发货/核账 库存 秒杀/预售 付款/退货 用户

1. 用户对库存的操作
    减库存(update) + 记录购买明细(insert) => 记录完整事务 数据落地
    (谁购买成功, 成功的时间/有效期, 付款/发货信息)

    事务:
        start transaction
            update 库存数量 <-- 竞争出现在这里
                行级锁: update table set num = num - 1 where id = 10 and num > 1;
                ==> 秒杀的难点在于如何高效的处理竞争
            insert 购买明细
        commit

        sku id = 2 kucun = 2

秒杀系统中会发生高并发的地方:
    1. 获得系统时间
        因为所有的html等静态资源是放在CDN中的, CDN必须向系统发送请求获得服务器的时间
        但实际上就是访问java的一个api, Java访问内存，一秒可以访问一亿次，10纳秒一次。
        因此, 不需要考虑高并发问题.
    2. 根据系统时间和秒杀商品的开始结束秒杀时间, 来获得是否可以秒杀, 以及秒杀地址
        用redis做服务器缓存, 一秒可抗10wQPS，可做集群分布式，可达到每秒百万QPS
        mysql和redis的一致性维护成本低:(超时过期, 从redis穿透到mysql, 主动更新)
    3. 秒杀操作优化分析
        无法使用CDN缓存
        无法使用redis, 因为库存问题, 会导致无法使用事务
        出现单行热门商品的mysql的update竞争

    大公司的解决方案:
        1.利用nosql实现一个原子计数器, 记录商品的库存, 保证原子性
        2.减库存之后, 会记录行为消息, 谁减了库存, 作为一个消息放在分布式消息队列中rocket mq, rabbit mq, active mq, kafka
        3.后端的服务会从mq中取出并消费这些消息, 存在mysql中
        优势: 可以抗住很高很高的并发(主要在第一步, 做成redis集群)
        劣势: 成本太大(运维成本, 开发成本, 无法保证同一用户重复秒杀(再维护一个nosql, 记录谁秒杀过了), 不适合新手)

    实际上:
        mysql直接对单行数据的update操作(同一个id执行update减库存) -- 一条的update可以支持4wQPS
        同一个商品, 1s内可以被卖4w次

        但如果用java控制事务, 由于有行级锁, 所以, 时间耗费在了等待获得锁
        更重要的是, java操作mysql, 会有网络延迟(比如北京的系统, 上海的mysql) 和gc的耗时. 这些也应该所在等待获得锁的耗时中.
        从update 减库存 -> insert 购买明细 -> commit/rollback
        (如果整个过程耗时2ms, 那么1s的QPS只有500次)
    优化方向: 减少行级锁的持有时间
        同城机房延迟(0.5-2ms) 异地机房延迟(13ms) max(1000qps, 50qps)
        gc(50ms) max(20qps)

        所以, 应该把客户端的逻辑放在mysql的服务器上, 避免java操作过程的网络延迟和gc影响
            1. 修改mysql源码, update之后自动提交
            2. 使用存储过程, 整个事务在mysql端完成
               简单优化:
                   从
                    update 减库存 -> insert 购买明细 -> commit/rollback
                              (等待行级锁)       (等待行级锁)
                   调整为:
                    insert 购买明细 -> update 减库存 -> commit/rollback
                              (无锁,可以并行)     (等待行级锁)
    总结:
        前端控制: 暴露接口, 防止秒杀按钮重复点击
        动静态数据分离: CDN缓存, 后端缓存
        事务竞争优化: 减少事务锁的时间

迭代开发
Sku == id 在一个品牌下每一个不同的组合(型号+颜色...)就是一个Sku
一个商品对应n个Sku

电商活动倒计时方案：
	1、确定一个基准时间。可以使用一个sql语句从数据库中取出一个当前时间。SELECT NOW()；
	2、活动开始的时间是固定的。
	3、使用活动开始时间-基准时间可以计算出一个秒为单位的数值。
	4、在redis中设置一个key（活动开始标识）。设置key的过期时间为第三步计算出来的时间。
	5、展示页面的时候取出key的有效时间。Ttl命令。使用js倒计时。
	6、一旦活动开始的key失效，说明活动开始。
	7、需要在活动的逻辑中，先判断活动是否开始。

秒杀方案：
	1、把商品的数量放到redis中。
	2、秒杀时使用decr命令对商品数量减一。如果不是负数说明抢到。
	3、一旦返回数值变为0说明商品已售完。

页面优化技术

1. 页面缓存 URL缓存 对象缓存
	页面缓存: 取缓存, 手动渲染模版, 结果输出
	瓶颈是数据库, 解决方案就是加缓存

2. 页面静态化, 前后端分离
	jsp thymeleaf都是动态网页, 但静态化是指页面就是纯的html, 通过js, ajax拿到数据来渲染页面.
	好处在于浏览器可以把HTML缓存在客户端, 这样只需要下载动态数据

3. 静态资源优化(js css 图片)

4. CDN优化

页面缓存: 时间较短, 比如1分钟
URL缓存, 根据id的不同, 显示不同的商品详情
对象缓存: 粒度最小, 比如缓存用户信息
页面静态化 -- 更为激进的缓存, 直接把页面缓存在了用户端的浏览器上.
js/css压缩, 组合, CDN就近访问

解决超卖
1. 数据库加商品id和用户id的唯一索引, 防止重复购买
2. sql加库存判断, 防止库存变成负数

核心思路是减少对数据库的访问
	1. 系统初始化的时候, 就把库存信息和数量放在redis中
		MiaoshaController实现InitializingBean接口, 实现其中的afterProperties方法, 在其中, 首先查到数据库中全部的秒杀商品, 然后遍历这个List, 把每个商品的库存数量都set到redis中.

	2. 收到请求之后, redis要预减库存, 如果库存不足, 则直接返回, 就可以减少对数据库的访问, 否则才进行下一步
		利用redis中的decr方法, 减少这个商品的库存数量
		然后到数据库中查询用户是否已经秒杀过了

	3. 把这个请求入队, 直接返回"排队中"
		入队的就是用户和商品id

	4. 请求出队, 生成订单, 减少库存
		在队列的receiver中, 接受到MiaoshaMessage, 拿出用户和商品id, 然后生成订单, 减少库存

	5. 客户端轮询, 查看是否秒杀成功


秒杀开始之前, 先去请求接口获取秒杀地址
	实际上就是前端请求这个接口, 然后后端返回一个随机字符串, 并存在redis中, 真正秒杀的时候, 需要带上这个随机字符串, 做验证
	然后再执行秒杀, 并且把这个随机字符串放在秒杀的地址中, 进行验证.

2. 数学公式验证码(防并发, 每个人输入计算的速度不同; 防爬虫)

1. 添加生成验证码的接口, 在生成验证码的时候, 不是简单的生成数字, 而是生成数学表达式, 然后通过ScriptEngine引擎来计算结果, 并把结果存入redis中.
2. 秒杀进行中时, 才需要把验证码的值显示出来. 也就是请求服务端的vertifyCode接口, 获取到验证码
3. 然后在前端发起秒杀请求的时候, 携带输入的验证码参数, 点击秒杀, 来到服务端的获取秒杀地址的接口里.
4. 这里接口要对输入的验证码进行验证, 也就是从redis中拿到对应商品的验证码的值进行对比.

3. 接口限流防刷

利用缓存, redis中的有效期, 设置有效期为1分钟, 设置一分钟内最大的访问次数, 如果来访问, 则访问次数加1, 超过限制则返回失败

可以在方法上加注解, 然后用拦截器拿到注解中配置的值
