es: 分布式搜索引擎, 主要做站内搜索
mysql: 利用其事务特性做稳定的数据存储

根据实际的数据, 聚合在不同类的表中, 先有数据, 再设计表
减少中间表的设计
尽量不要用外键, 而是用逻辑上的外键. 否则将来数据庞大之后, 要进行分库分表, 外键就是一种束缚.

运行spring boot项目的maven命令: mvn spring-boot:run

主键产生策略通过GenerationType来指定。GenerationType是一个枚举，它定义了主键产生策略的类型。
1、AUTO　自动选择一个最适合底层数据库的主键生成策略。如MySQL会自动对应auto increment。这个是默认选项，即如果只写@GeneratedValue，等价于@GeneratedValue(strategy=GenerationType.AUTO)。
2、IDENTITY　表自增长字段，Oracle不支持这种方式。
3、SEQUENCE　通过序列产生主键，MySQL不支持这种方式。
4、TABLE　通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。不同的JPA实现商生成的表名是不同的，如 OpenJPA生成openjpa_sequence_table表，Hibernate生成一个hibernate_sequences表，而TopLink则生成sequence表。这些表都具有一个序列名和对应值两个字段，如SEQ_NAME和SEQ_COUNT。

在我们的应用中，一般选用@GeneratedValue(strategy=GenerationType.AUTO)这种方式，自动选择主键生成策略，以适应不同的数据库移植。

@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

JpaConfig：
@Configuration
@EnableJpaRepositories(basePackages = "com.imooc.repository")
@EnableTransactionManagement
public class JPAConfig {
    /**
     * 配置数据源
     * @return
     */
    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    /**
     * 配置实体类的管理
     * @return
     */
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        HibernateJpaVendorAdapter japVendor = new HibernateJpaVendorAdapter();
        japVendor.setGenerateDdl(false);

        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();
        entityManagerFactory.setDataSource(dataSource());
        entityManagerFactory.setJpaVendorAdapter(japVendor);
        entityManagerFactory.setPackagesToScan("com.imooc.entity");
        return entityManagerFactory;
    }

    /**
     * 配置事务管理器
     * @param entityManagerFactory
     * @return
     */
    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory);
        return transactionManager;
    }
}


配置文件：
# jpa config
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/xunwu
spring.datasource.username=root
spring.datasource.password=root

# 打印sql，方便调试
spring.jpa.show-sql=true
# 只校验sql的正确性, 只做sql表的格式验证，不会做增删改的操作
spring.jpa.hibernate.ddl-auto=validate
# 打印sql需要在debug级别下
logging.level.org.hibernate.SQL=debug

# 最初的session存储的配置
spring.session.store-type=hash_map

# 关闭HTTP基本验证
security.basic.enabled=false

JPA通用的主键生成策略有四种，hibernate自己的主键生成策略更多。
TABLE：使用一个特定的数据库表格来保存主键。 
SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。（从1开始，每次递增10） 
IDENTITY：主键由数据库自动生成（主要是自动增长型） 自动维护
AUTO：是默认的配置。如果一个实体类要兼容两个数据库，就不能使用这个AUTO

JPA中用Long类型的id主键，其他属性可以加@Column注解，一一对应java名和sql名

在做单元测试的时候，可以把springboot默认生成的主类当成父类，其他单测都继承这个类即可

前端配置：WebMvcConfig
/**
 * ApplicationContextAware 可以获取spring的上下文
 */
@Configuration
public class WebMvcConfig extends WebMvcConfigurerAdapter implements ApplicationContextAware {

    @Value("${spring.thymeleaf.cache}")
    private boolean thymeleafCacheEnable = true;

    //这个就是获取的spring上下文，通过set方法注入值
    private ApplicationContext applicationContext;
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    /**
     * 把静态资源如js css等加载到thymeleaf中的配置
     */
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }

    /**
     * 1. 模板资源解析器
     * @return
     */
    @Bean
    @ConfigurationProperties(prefix = "spring.thymeleaf")
    public SpringResourceTemplateResolver templateResolver() {
        SpringResourceTemplateResolver templateResolver = new SpringResourceTemplateResolver();
        templateResolver.setApplicationContext(this.applicationContext);
        templateResolver.setCharacterEncoding("UTF-8");
        templateResolver.setCacheable(thymeleafCacheEnable);
        return templateResolver;
    }

    /**
     * 2. Thymeleaf标准方言解释器
     */
    @Bean
    public SpringTemplateEngine templateEngine() {
        SpringTemplateEngine templateEngine = new SpringTemplateEngine();

        templateEngine.setTemplateResolver(templateResolver());

        // 支持Spring EL表达式
        templateEngine.setEnableSpringELCompiler(true);

        // 支持SpringSecurity方言(登录成功后,结合thymeleaf模版, 把已经登录的用户的用户名显示出来)
        SpringSecurityDialect securityDialect = new SpringSecurityDialect();
        templateEngine.addDialect(securityDialect);
        return templateEngine;
    }

    /**
     * 3. 视图解析器
     */
    @Bean
    public ThymeleafViewResolver viewResolver() {
        ThymeleafViewResolver viewResolver = new ThymeleafViewResolver();
        viewResolver.setTemplateEngine(templateEngine());
        return viewResolver;
    }

    /**
     * Bean Util，用于在pojo和dto之间的转化
     * @return
     */
    @Bean
    public ModelMapper modelMapper() {
        return new ModelMapper();
    }
}

Api设计
1. web包里放controller，dto，form

2. 异常拦截器包括两个部分，页面异常拦截器和Api异常拦截器

# 取消springboot的默认错误页面的显示, 而用我们自己的错误页面
server.error.whitelabel.enabled=false
# springboot热部署时, 取消对静态资源的监控
spring.devtools.restart.exclude=templates/**,static/**

/**
 * web错误 全局配置
 * Created by 瓦力.
 */
@Controller
public class AppErrorController implements ErrorController {

    //1. 指定错误页面的路径
    private static final String ERROR_PATH = "/error";
    @Override
    public String getErrorPath() {
        return ERROR_PATH;
    }

    //2.注入错误属性信息
    private ErrorAttributes errorAttributes;
    @Autowired
    public AppErrorController(ErrorAttributes errorAttributes) {
        this.errorAttributes = errorAttributes;
    }

    /**
     * 3. Web页面错误处理
     * 根据response的status来决定返回哪个错误页面
     */
    @RequestMapping(value = ERROR_PATH, produces = "text/html")
    public String errorPageHandler(HttpServletResponse response) {
        int status = response.getStatus();
        switch (status) {
            case 403:
                return "403";
            case 404:
                return "404";
            case 500:
                return "500";
        }

        return "index";
    }

    /**
     * 4. 除Web页面外的错误处理，比如Json/XML等
     */
    @RequestMapping(value = ERROR_PATH)
    @ResponseBody
    public ApiResponse errorApiHandler(HttpServletRequest request) {
        RequestAttributes requestAttributes = new ServletRequestAttributes(request);

        //从requestAttributes获得错误信息
        Map<String, Object> attr = this.errorAttributes.getErrorAttributes(requestAttributes, false);
        int status = getStatus(request);

        //第二个参数的意思是: if stack trace elements should be included
        return ApiResponse.ofMessage(status, String.valueOf(attr.getOrDefault("message", "error")));
    }

    private int getStatus(HttpServletRequest request) {
        //从request中拿到状态码
        Integer status = (Integer) request.getAttribute("javax.servlet.error.status_code");
        if (status != null) {
            return status;
        }

        return 500;
    }
}

3. ApiResponse的设计

public class ApiResponse {
    private int code;
    private String message;
    private Object data;
    //表示数据集是否还有更多的信息
    private boolean more;

    public ApiResponse(int code, String message, Object data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    public ApiResponse() {
        this.code = Status.SUCCESS.getCode();
        this.message = Status.SUCCESS.getStandardMessage();
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }

    public boolean isMore() {
        return more;
    }

    public void setMore(boolean more) {
        this.more = more;
    }

    //以下是三种方便返回的ApiResponse静态方法
    //1. 成功时, 只返回data(ofSuccess)
    //2. 失败时, 返回code和message(ofMessage), data是null
    //3. 失败时, 还可以只传一个集合了code和message的Status枚举作为参数返回(ofStatus)

    public static ApiResponse ofMessage(int code, String message) {
        return new ApiResponse(code, message, null);
    }

    public static ApiResponse ofSuccess(Object data) {
        return new ApiResponse(Status.SUCCESS.getCode(), Status.SUCCESS.getStandardMessage(), data);
    }

    public static ApiResponse ofStatus(Status status) {
        return new ApiResponse(status.getCode(), status.getStandardMessage(), null);
    }

    //自定义的返回结果枚举类

    public enum Status {
        SUCCESS(200, "OK"),
        BAD_REQUEST(400, "Bad Request"),
        NOT_FOUND(404, "Not Found"),
        INTERNAL_SERVER_ERROR(500, "Unknown Internal Error"),
        NOT_VALID_PARAM(40005, "Not valid Params"),
        NOT_SUPPORTED_OPERATION(40006, "Operation not supported"),
        NOT_LOGIN(50000, "Not Login");

        private int code;
        private String standardMessage;

        Status(int code, String standardMessage) {
            this.code = code;
            this.standardMessage = standardMessage;
        }

        public int getCode() {
            return code;
        }

        public void setCode(int code) {
            this.code = code;
        }

        public String getStandardMessage() {
            return standardMessage;
        }

        public void setStandardMessage(String standardMessage) {
            this.standardMessage = standardMessage;
        }
    }
}

使用H-ui来实现后台管理功能

使用es建立索引, 方便搜索数据的唯一标识, 而不是要搜数据的每一个字段, 但要在索引中加上house_id, 实际的数据是从mysql中查出的

以后的查询不用拼json字符串, 然后发送rest请求来操作es, 而是要建立一个和索引有关的类, 操作这个类即可

es适合做检索, mysql适合做原始数据的存储

ElasticSearchConfig.java
@Configuration
public class ElasticSearchConfig {

    @Value("${elasticsearch.host}")
    private String esHost;

    @Value("${elasticsearch.port}")
    private int esPort;

    @Value("${elasticsearch.cluster.name}")
    private String esName;

    @Bean
    public TransportClient esClient() throws UnknownHostException {
        Settings settings = Settings.builder()
                .put("cluster.name", this.esName)
//                .put("cluster.name", "elasticsearch")
                .put("client.transport.sniff", true)
                .build();

        InetSocketTransportAddress master = new InetSocketTransportAddress(
            InetAddress.getByName(esHost), esPort
//          InetAddress.getByName("10.99.207.76"), 8999
        );
        //9300是tcp的监听端口

        TransportClient client = new PreBuiltTransportClient(settings)
                .addTransportAddress(master);

        return client;
    }
}

Kafka构建索引: Kafka会把数据存在磁盘上.

zookeeper: 分布式配置和同步服务, kafka是通过zookeeper共享信息的

解压kafka后, 其自带zookeeper
nohup ./bin/zookeeper-server-start.sh config/zookeeper.properties &
vim nohup.out

server.properties中
broker.id 如果是一个集群, 则每个实例的broker.id是个唯一的值

启动kafka
nohup ./bin/kafka-server-start.sh config/server.properties & 

创建topic
./bin/kafka-topic.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic hello

展示所有topic
./bin/kafka-topic.sh --list --zookeeper localhost:2181

发送消息(命令行)
./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic hello

接受消息
./bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic hello --from-beginning

房屋上架等情况下, 需要构建索引, 需要把它变成异步的服务, 也就是用kafka这样的消息队列, 做一些耗时的任务

