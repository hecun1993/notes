## 一致性哈希算法
#### 场景一
* 假设后端集群包含三台缓存服务器，A、B、C。请求r1、r2落在A上。请求r3、r4落在B上。请求r5、r6落在C上。  
* 使用一致性哈希时，当缓存服务器B宕机时，r1/r2会仍然落在A上，r5/r6会仍然落在C上，也就是说这两台服务器上的缓存都不会失效。r3/r4会被重新分配给A或者C，并产生回源。  
* 使用其它算法，当缓存服务器B宕机时，r1/r2不再落在A上，r5/r6不再落在C上了。也就是说A、B、C上的缓存都失效了，所有的请求都要回源。

#### 场景二
* 假设有100台redis data服务器，一份数据101进来的时候，以散列公式hash(i)%100，计算所存放的服务器。假设hash(i) = 101, 那么数据被散列到标号为1的服务器。
* 然后服务器新增了一台，散列公式为hash(i)%101，这时请求访问数据101的时候，被分配至0号服务器。但是其实数据是在1号服务器的。
* 所以这个时候大量的数据失效了（访问不到了）。
* 为了解决这个问题，当新增服务器的时候：如果是持久化存储，可以让服务器集群对数据进行重新散列，进行数据迁移，然后进行恢复。但是这就意味着每次增减服务器的时候，集群就需要大量的通信，进行数据迁移，这个开销是非常大的。如果只是缓存，那么缓存就都失效了。

**关键问题在于，服务器数量变动的时候，要能够保证旧的数据能够按照老的算法，计算得到数据所在的服务器。而新的数据能够按照新的散列算法，计算出数据所在的服务器。**

---

#### 算法描述
* 1. 平衡性：
* 平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
* 2. 单调性(Monotonicity)
* 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，此时又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。

> 将对象和服务器都映射到同一个hash数值空间中，并且使用相同的hash算法。在这个环形空间中，如果沿着顺时针方向从对象的key值出发，直到遇见一个服务器，那么就将该对象存储在这个服务器上。  
> 因为对象和服务器的hash值是固定的，因此这个服务器必然是唯一和确定的。


## 哈希算法

**哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。**

**如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法。**

**既然输入数据不定长，而输出的哈希值却是固定长度的，这意味着哈希值是一个有限集合，而输入数据则可以是无穷多个。那么建立一对一关系明显是不现实的。所以"碰撞"(不同的输入数据对应了相同的哈希值)是必然会发生的，所以一个成熟的哈希算法会有较好的抗冲突性。同时在实现哈希表的结构时也要考虑到哈希冲突的问题。**

**HASH算法是密码学的基础，比较常用的有MD5和SHA，最重要的两条性质，就是不可逆和无冲突。所谓不可逆，就是当你知道x的HASH值，无法求出x；所谓无冲突，就是当你知道x，无法求出一个y， 使x与y的HASH值相同。**

**这两条性质在数学上都是不成立的。因为一个函数必然可逆，且由于HASH函数的值域有限，理论上会有无穷多个不同的原始值，它们的hash值都相同。MD5和SHA做到的，是求逆和求冲突在计算上不可能，也就是正向计算很容易，而反向计算即使穷尽人类所有的计算资源都做不到。**

**记录的存储位置=f(关键字)。这里的对应关系f称为散列函数，又称为哈希（Hash函数），采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash table）。**

**哈希表hashtable(key，value) 就是把Key通过一个固定的算法函数即所谓的哈希函数，转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。（或者：把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。）**

**而当使用哈希表进行查询的时候，就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位**。

**哈希表有多种不同的实现方法，比如拉链法，可以理解为“链表的数组”。左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。**

**Hash Table的查询速度非常的快，几乎是O(1)的时间复杂度。hash就是找到一种数据内容和数据存放地址之间的映射关系。**

哈希（Hash）是一种数据编码方式，将大尺寸数据（如一句话，一张图片，一段音乐、一个视频等）浓缩到一个数字中，从而方便地实现数据匹配·查找的功能。比如这里有一万首歌，要求按照某种方式保存好。到时候给你一首新的歌（命名为X），要求你确认新的这首歌是否在那一万首歌之内。

无疑，将一万首歌一个一个比对非常慢。但如果存在一种方式，能将一万首歌的每一首的数据浓缩到一个数字（称为哈希码）中，于是得到一万个数字，那么用同样的算法计算新的歌X的编码，看看歌X的编码是否在之前那一万个数字中，就能知道歌X是否在那一万首歌中。

将一首歌的5M字节数据浓缩到一个数字中的算法就是哈希算法。那一万首歌按照各自的编码数字从小到大排序后得到的一个表就是哈希表。

作为例子，如果要你组织那一万首歌，一个简单的哈希算法就是让歌曲所占硬盘的字节数作为哈希码。这样的话，你可以让一万首歌“按照大小排序”，然后遇到一首新的歌，只要看看新的歌的字节数是否和已有的一万首歌中的某一首的字节数相同，就知道新的歌是否在那一万首歌之内了。

对于一万首歌的规模而言，这个算法已经相当好，因为两首歌有完全相同的字节数是不大可能的。就算真有极小概率出现不同的歌有相同的哈希码，那也只有寥寥几首歌，此时再逐首比对即可。
