#### ApplicationContext

##### 获取Spring的上下文ApplicationContext的方法

1. 手动创建ApplicationContext对象，并保存起来。

public class ApplicationContextUtil {  
    private static ApplicationContext context;  
  
    static {  
        context = new ClassPathXmlApplicationContext("applicationContext.xml");  
    }  
  
    public static ApplicationContext getApplicationContext() {  
        return context;  
    }  
}  

2. 在web环境中通过spring提供的工具类获取，需要ServletContext对象作为参数。然后才通过ApplicationContext对象获取bean。

下面两个工具方式的区别是，前者在获取失败时返回null，后者抛出异常。另外，由于spring是容器的对象放在ServletContext中的，所以可以直接在ServletContext取出 WebApplicationContext 对象。

ApplicationContext context1 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);  

ApplicationContext context2 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);  

WebApplicationContext webApplicationContext = (WebApplicationContext) servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);  

3. 工具类继承抽象类 ApplicationObjectSupport，并在工具类上使用@Component交由spring管理。这样spring容器在启动的时候，会通过父类ApplicationObjectSupport中的setApplicationContext()方法将ApplicationContext对象设置进去。可以通过getApplicationContext()得到ApplicationContext对象。

4. 工具类继承抽象类WebApplicationObjectSupport，查看源码可知WebApplicationObjectSupport是继承了ApplicationObjectSupport，所以获取ApplicationContext对象的方式和上面一样，也是使用getApplicationContext()方法。

5. 工具类实现ApplicationContextAware接口，并重写setApplicationContext(ApplicationContext applicationContext)方法，在工具类中使用@Component注解让spring进行管理。spring容器在启动的时候，会调用setApplicationContext()方法将ApplicationContext 对象设置进去。

@Component  
public class ApplicationContextUtil implements ApplicationContextAware {  
    private static ApplicationContext context;  
  
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {  
        context = applicationContext;  
    }  
      
    public static ApplicationContext getApplicationContext() {  
        return context;  
    }  
}


使用XML作为配置的时候，实例的ApplicationContext是ClassPathXmlApplicationContext
通过@Configuration注解的类，实例化的ApplicationContext是AnnotationConfigApplicationContext

ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);

注意:
1. AnnotationConfigApplicationContext不仅仅可以和注解了@Configuration的类配合，任何注解了@Component或者是JSR-330的类同样可以作为输入来构造Spring容器

ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);

2. AnnotationConfigApplicationContext类除了通过类来初始化，也可以通过无惨构造函数来进行构造，之后通过register()方法来配置。这种方法在通过编程的方式来构建AnnotationConfigApplicationContext的过程很有用。

public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}

注意:
ConfigurableApplicationContext WebApplicationContext 分别继承了 ApplicationContext 接口
ConfigurableWebApplicationContext结合了上述两者的优点, 分别继承了上述两个接口, 允许通过配置的方式实例化WebApplicationContext. 凡是以Configurable开头的, 都是可配置的, 就会有addxxx的方法

AnnotationConfigApplicationContext 类就实现了这个根接口 ConfigurableApplicationContext