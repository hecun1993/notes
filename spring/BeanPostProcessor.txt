#### BeanPostProcessor

1. BeanPostProcessor与InitializingBean的区别

BeanPostProcessor接口对所有的bean都起作用，即所有的bean初始化前后都会回调BeanPostProcessor实现类中的方法;
InitializingBean和DisposableBean接口是针对单个bean的，即只有在对应的bean实现了InitializingBean或DisposableBean接口才会调用其方法;

执行顺序:

Bean自己的构造方法-->BeanPostProcessor-->InitializingBean-->bean中的初始化方法。

```java
public interface BeanPostProcessor {
	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException;
	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;
}
```

2. 调用时机

postProcessBeforeInitialization的调用时机: 
    在bean实例化，依赖注入之后及自定义初始化方法之前调用
        配置文件中bean标签添加init-method属性指定Java类中初始化方法
        @PostConstruct注解指定初始化方法
        Java类实现InitailztingBean接口

postProcessAfterInitialization的调用时机:
    在bean实例化、依赖注入及自定义初始化方法之后调用
    即在调用InitializingBean的afterPropertiesSet()方法或对应init-method方法之后。

3. 方法解释

两个方法的参数以及返回值对应的意义都是一样的，其中参数bean表示当前状态的bean，参数beanName表示当前bean的名称，而方法对应的返回值即表示需要放入到bean容器中的bean;

所以用户如果有需要完全可以在这两个方法中对bean进行修改，即封装自己的bean进行返回。

4. 注册

只需要把它当做一个普通的bean定义到Spring的bean容器中，Spring将能够自动检测到它，并将它注册到当前的bean容器中。

BeanPostProcessor是容器绑定的，即BeanPostProcessor只能对跟它属于同一个bean容器中的bean进行回调，即BeanPostProcessor不能对属于它父容器或子容器中的bean进行回调。

在bean容器中定义了BeanPostProcessor之后，Spring将最先将BeanPostProcessor对应的bean进行实例化，如果我们制定BeanPostProcessor的lazy-initialization=”true”或default-lazy-initialization=”true”，Spring将对其进行忽略，即这些配置对BeanPostProcessor不起作用

5. 回调顺序

在bean容器中可以同时定义多个BeanPostProcessor，这样在新实例化一个bean后将依次使用每个BeanPostProcessor回调一遍. 当然，如果某一个BeanPostProcessor回调后的返回的bean为null，则不再继续往下回调，将直接返回null，这个时候bean容器中对应beanName对应的bean也是null。

当在一个bean容器中同时定义有多个BeanPostProcessor时，默认将根据BeanPostProcessor在bean容器中定义的先后顺序对新实例化的bean进行回调。

还有一种定义BeanPostProcessor回调顺序的方法是: 将我们自定义的BeanPostProcessor实现类同时实现Ordered接口，然后Spring将根据Ordered接口定义的getOrder()方法的返回值来决定BeanPostProcessor回调的先后顺序，getOrder()返回值越小的越先进行回调。

此外，实现了Ordered接口的BeanPostProcessor总是比没有实现Ordered接口的BeanPostProcessor先进行回调，为了便于管理，推荐要么都实现Ordered接口，要么都不实现。

6. 实例

```java
@Component
public class HelloBeanPostProcessor implements BeanPostProcessor, Ordered {
	private int order;
	
    public Object postProcessBeforeInitialization(Object bean, String beanName)
			throws BeansException {
		System.out.println("beanName-----------" + beanName);
		return bean;
	}

	public Object postProcessAfterInitialization(Object bean, String beanName)
			throws BeansException {
		return bean;
	}

	public void setOrder(int order) {
		this.order = order;
	}
	
	public int getOrder() {
		return order;
	}
}
```

7. BeanFactory和ApplicationContext对待bean后置处理器稍有不同

1. ApplicationContext会自动检测在配置文件中实现了BeanPostProcessor接口的所有bean。并把他们注册为后置处理器，然后在容器创建bean的适当时候调用它。因此部署一个后置处理器同部署其他bean并没有什么区别。直接用注解或者xml配置即可

<bean class="TestBeanPostProcessor" />

2. 而使用BeanFactory实现的时候，bean后置处理器必须通过代码显式的去注册，在IOC容器集成体系中ConfingurableBeanFactory接口中定义了注册方法。

```java
TestBeanPostPrcessor beanPostProcessor = new TestBeanPostPrcessor();
Resource resource = new FileSystemResource("applicationContext.xml");
ConfigurableBeanFactory factory = new XmlBeanFactory(resource);
factory.addBeanPostProcessor(beanPostProcessor);
factory.getBean("logic");
```