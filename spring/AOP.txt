#### 底层原理（BeanPostProcessor）
spring 提供一种机制，只要我们写的类实现BeanPostProcessor接口，并将实现类提供给spring容器(<bean class=""> 不需要写id)，spring容器将自动在初始化方法(init)前执行before()，在初始化方法后执行after() 

目的是修改容器中所有的bean对象，创建代理对象，是AOP的底层。
这里创建的代理对象，可以在before方法中返回代理对象，也可以在after方法中返回代理对象。  

public class MyBeanPostProcessor implements BeanPostProcessor {
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    	System.out.println("前方法 ： " + beanName);
    	return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
    	System.out.println("后方法 ： " + beanName);
    	// bean 目标对象
    	// 生成 jdk 代理
    	return Proxy.newProxyInstance(
            MyBeanPostProcessor.class.getClassLoader(), 
            bean.getClass().getInterfaces(), 
            new InvocationHandler(){
            	@Override
            	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    System.out.println("开启事务");
            		
                    //执行目标方法
                    Object obj = method.invoke(bean, args);
                    
                    System.out.println("提交事务");
                    return obj;
            	}
            }
        );
    }
}

#### AOP的概念

1. AOP指面向切面编程。通过预编译方式，或者主要是运行期间的动态代理技术来实现功能。它可以使业务逻辑各部分之间的耦合度降低，提高程序的可重用性
2. 采取横向抽取机制，取代了传统纵向继承体系重复性代码  
具体指，比如原来要为Service中的add和delete两个方法添加事务的操作，而且不能修改原先的代码。那么我们只能另外写一个类A来继承Service类，然后分别在add和delete方法的前后，加事务开启和事务提交。  
但是，如果使用AOP，我们就可以直接写一个A类，里面是开启和提交事务的方法，然后把A类和Service全部交给Spring，让它为我们产生代理对象。  
3. 经典应用：事务管理、性能监视、安全检查、缓存 、日志等。  

第一种情况，有接口情况，使用动态代理创建接口实现类代理对象  
第二种情况，没有接口情况，使用cglib代理创建类的子类代理对象

#### 术语
Joinpoint(连接点): 指类里面可以被增强的方法。  
Pointcut(切入点)：指我们要进行拦截增强的那些连接点。
Advice(通知/增强)：指对切入点所做的事情。通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)  
Aspect(切面): 是切入点和通知的结合。 
Weaving(织入)：把增强advice应用到目标对象target来创建新的代理对象proxy的过程。
目标类：需要被代理的类。  
代理类：Proxy  
