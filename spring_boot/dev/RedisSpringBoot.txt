1. 添加缓存不能影响正常业务逻辑。所以要使用try catch
2. 命中 失效 更新
3. 在启动类上加@EnableCaching的注解
4. 在查询方法上加@Cacheable(cacheNames = "product", key = "123") 要返回的实体类继承序列化接口
	1. 第一次访问时, 会访问数据库, 同时把数据存在redis中
	2. redis中的key: "product:123"
	3. 如果不写括号中的key, 那么其值就是方法中的参数的值
	4. 根据参数进行判断决定是否缓存: 
		@Cacheable(cacheNames = "product", key = "#sellerId", condition = "#sellerId.length() > 3")
	5. 根据结果的code判断是否要缓存: 
		@Cacheable(cacheNames = "product", key = "#sellerId", unless = "#result.getCode() != 0")
		public ResultVO list(String sellerId) {}
5. 在更新方法上加@CachePut(cacheNames = "product", key = "123")
	这样就会更新缓存
	==> @CachePut 每次都会执行方法, 然后把更新同步到redis中. 
		但是, 如果更新方法返回的是视图ModelAndView对象, 那么, 无法让ModelAndView对象实现序列化接口, 所以, @CachePut不行. ==> 需要换一种缓存同步的方式
		如果想用@CachePut和@Cacheable, 就需要查询方法和更新方法返回的数据一致.
	==> @CacheEvict(cacheNames = "product", key = "123") 只要访问这个更新方法, 就会把redis中的缓存清除掉. 从而实现缓存同步.

Redis中只能保存字符串,所以要把list等都转成json字符串，要有JsonUtils类
