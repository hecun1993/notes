#### SpringBootServletInitializer（用在打成war包，发布到tomcat中）

打包springboot项目, 或者需要使用jsp: 

1. 添加provided依赖, 只在编译时使用tomcat的依赖, 因为打包成war包, 发布到服务器上, 服务器有tomcat
所以, 要用provided
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-tomcat</artifactId>
			<scope>provided</scope>
		</dependency>

2. 添加maven-war-plugin插件
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-war-plugin</artifactId>
            <configuration>
                <failOnMissingWebXml>false</failOnMissingWebXml>
            </configuration>
        </plugin>

3. <packaging>war</packaging>

4. 将项目的启动类Application.java继承SpringBootServletInitializer并重写configure方法
	@SpringBootApplication
	public class Application extends SpringBootServletInitializer {
		@Override
		protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
			return application.sources(Application.class);
		}
		public static void main(String[] args) throws Exception {
			SpringApplication.run(Application.class, args);
		}
	}

1. 如果是多模块应用，提示找不到主类，需要把build节点的信息放在web模块（核心模块）中，同时添加主类信息
2. 多模块应用，主模块可以删掉src文件夹，要注意不同模块之间的依赖关系
3. 如果打包方式是war，则需要添加webapp/WEB-INF/web.xml

```xml
<build>
	<plugins>
        <plugin>
            <grounpId>org.spring.framework.boot</grounpId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <mainClass>com.imooc.firstappdemo.FirstAppDemoApplication</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>
```

#### 源码分析

1. SpringServletContainerInitializer implements ServletContainerInitializer接口, 该接口负责在启动容器时负责加载相关配置
	public interface ServletContainerInitializer {
		public abstract void onStartup(Set<Class<?>> paramSet, ServletContext paramServletContext) throws ServletException;
	}

2. 在SpringServletContainerInitializer类上有注解@HandlesTypes(WebApplicationInitializer.class)

3. 因为这个类声明了HandlesTypes，并指定了类型为WebApplicationInitializer.class，在Servlet3.0+的web容器启动时，会扫描类路径下所有的WebApplicationInitializer接口实现类，并把它们放到一个set集合, 提供给给onStartup方法执行。

而 abstract class SpringBootServletInitializer implements WebApplicationInitializer {} 也就是说, SpringBootServletInitializer是WebApplicationInitializer的实现类, 所以会放入set集合中, 而DemoApplication也是WebApplicationInitializer的实现类, 也会放入set集合中.

4. onStartup方法执行时，会遍历该set，并使用newInstance()方式进行实例化，实例化后依据@Order注解进行排序，最后在依次调用onStartup(ServletContext)方法
		for (WebApplicationInitializer initializer : initializers) {
			initializer.onStartup(servletContext);
		}
在initializer.onStartup(servletContext);方法中, 会调用createRootApplicationContext方法，通过SpringApplicationBuilder构建并封装SpringApplication对象，并最终调用SpringApplication的run方法的过程, 完成初始化。

5. DemoApplication extends SpringBootServletInitializer
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        builder.sources(DemoApplication.class);
        return builder;
    }

6. 所以，打成war包的时候，需要启动类继承自SpringBootServletInitializer，方可正常部署至常规tomcat下，其主要能够起到web.xml的作用，注入一些filter，listener的配置。

在web容器启动时为提供给第三方组件机会做一些初始化的工作，，例如注册servlet或者filtes等, 容器根据Servlet规范, 提供了javax.servlet.ServletContainerInitializer。第三方的应用需要基于SPI机制，来实现javax.servlet.ServletContainerInitializer 接口。也就是需要在对应的jar包的META-INF/services 目录创建一个名为javax.servlet.ServletContainerInitializer的文件，文件内容指定具体的ServletContainerInitializer实现类，那么，当web容器启动时就会运行这个初始化类做一些组件内的初始化工作。 