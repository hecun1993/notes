META-INF/spring.factories
在spring3.2中, 由SpringFactoriesLoader类中定义的常量
这个类似于java中的ServiceLoader(META-INT/service.factories)

@EnableConfigurationProperties注解一般和ConfigurationProperties注解搭配使用，可以将配置文件属性注入到bean中。

@Import其实就是引入一个或多个配置，可以导入普通类，也可以导入配置类。
@Import用来导入一个或多个类（会被spring容器管理），或者配置类（配置类里的@Bean标记的类也会被spring容器管理）

我们要将这四个类纳入到spring容器中，我们之前的做法是在User，People上加上了@Component注解(或者@Service，@Controller）或者在MyConfig类上加上@Configuration注解。很显然我们这边并没有这般做，使用@Import注解也可以加对象纳入到spring容器中。

@Import({User.class,People.class, MyConfig.class})
public class Application {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class,args);
        System.out.println(context.getBean(User.class));
        System.out.println(context.getBean(Dog.class));
        System.out.println(context.getBean(Cat.class));
        System.out.println(context.getBean(People.class));
    }
}

ImportSelector接口
    定义一个MyImportSelector继承ImportSelector，ImportSelector返回的String[]数组是类的全类名会被纳入到spring容器内。

    进入EnableAutoConfiguration注解源码，发现是导入EnableAutoConfigurationImportSelector类，它继承了ImportSelector接口, ImportSelector接口的selectImports返回的数组（类的全类名）都会被纳入到spring容器中.

    进入org.springframework.boot.autoconfigure.AutoConfigurationImportSelector类，进入getCandidateConfigurations方法. getCandidateConfigurations会到classpath下的读取META-INF/spring.factories文件的配置，并返回一个字符串数组。

    调试的时候读取到了我们在spring.factories中配置的core.bean.MyConfig，也读到了一些其他的配置

    (springboot项目B依赖了A项目中的一个类, 并且把A中的配置类的全类名放在B中的classpath下的META-INF/spring.factories中)

@EnableAutoConfiguration 作用:
    从classpath中搜索所有META-INF/spring.factories配置文件然后，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器
    只有spring.boot.enableautoconfiguration为true（默认为true）的时候，才启用自动配置
    @EnableAutoConfiguration还可以进行排除，排除方式有2中，一是根据class来排除（exclude），二是根据class name（excludeName）来排除

其内部实现的关键点有
    1）ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中
    2）SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF/spring.factories配置文件，并读取配置

@Condition注解: spring4提供的
    @ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean）
    @ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean）
    @ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean）
    @ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean）
    @ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean）
    @ConditionalOnNotWebApplication（不是web应用）

    @ConditionalOnClass：该注解的参数对应的类必须存在，否则不解析该注解修饰的配置类；
    @ConditionalOnMissingBean：该注解表示，如果存在它修饰的类的bean，则不需要再创建参数里的这个bean；可以给该注解传入参数例如@ConditionOnMissingBean(name = "example")，这个表示如果name为“example”的bean存在，这该注解修饰的代码块不执行。

=============================================

spring boot自动加载的源码分析
	1.RedisProperties -> RedisConnectionConfiguration -> RedisAutoConfiguration
	2.SpringApplication对象被实例化 -> 加载spring.factories文件

	- 比如在主配置文件application.yml中配置了redis的配置项
	- spring.redis.port = 6379
	- 则首先会有RedisProperties类从配置文件中读取到这些属性，然后封装成RedisProperties类
	- 接着，这个类会变成RedisConnectionConfiguration类的一个属性，而这个RedisConnectionConfiguration类又会成为RedisAutoConfiguration类的一个属性。
	- 这样，就会自动配置redis了。
	- springboot启动的时候，会实例化SpringApplication对象，在这个过程中，会加载META-INF/spring.factories文件，在这个文件中定义了类似于RedisAutoConfiguration等一系列的类，这些类都会被加载到spring容器中。