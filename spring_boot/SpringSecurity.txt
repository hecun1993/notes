spring security基本原理:
	1. 一般, 请求和响应是在一个线程中完成的
    2. 请求 -> UsernamePasswordAuthenticationFilter(表单登录) -> BasicAuthenticationFilter(原始登录) -> ... -> ExceptionTranslationFilter(捕获后一个拦截器产生的异常, 决定后续的步骤) -> FilterSecurityInterceptor(根据配置查看这个用户需要经过哪些验证, 看session中是否有用户信息, 有则可以访问rest api, 否则就抛出异常) -> rest api

	1. 登录请求发来后, 首先来到UsernamePasswordAuthenticationFilter(是过滤器链上的一个过滤器, 负责处理登录请求).
	2. 然后用拿到的登录名和密码, 构建一个UsernamePasswordAuthenticationToken的对象, 它是Authentication接口的实现. 然后把请求的相关信息也放在UsernamePasswordAuthenticationToken对象中
	3. 使用AuthenticationManager,这个类本身不包含认证的逻辑,它的作用是用来收集和管理一组AuthenticationProvider(不同的登录方式, 认证逻辑不同). 首先拿到一组AuthenticationProviders, 然后for循环, 调用supports方法判断是否支持传入的Authentication的类型.
		return this.getAuthenticationManager().authenticate(usernamePasswordAuthenticationToken);
	4. 找出Provider之后, 执行验证. 过程中调用提供的UserDetailsService的实现, 根据用户名获得用户信息UserDetails. 然后进行预检查,密码检查和后检查. 如果检查都通过, 则重新创建UsernamePasswordAuthenticationToken对象, 把权限信息设置进去.
	5. 登录成功, 调用onAuthenticationSuccess方法, 登录成功的处理器. 

认证结果如何在多个请求间共享:request
	1. 最初的想法: 放在session中.
	2. 把认证成功后构建的UsernamePasswordAuthenticationToken对象封装在SecurityContext中, 然后放在SecirutyContextHolder中.
	3. SecirutyContextHolder是ThreadLocal的一个封装. 它是与线程绑定的map. 在同一个线程中, 这个方法里放的变量, 另外一个方法中可以读出. 可以理解为线程级别的变量.
	4. SecurityContextPersistenceFilter在整个过滤器链的最前面.
	作用是检查session中是否有SecurityContext, 如果有, 就拿到线程变量中. 在返回时, 如果有, 就放到session中.
		SecurityContextHolder.getContext().getAuthentication();	

OAuth协议(授权协议)存在的目的:
    让第三方应用可以在不知道用户的用户名密码的情况下, 访问用户存在应用服务器上的(自拍)数据

当(自拍)数据变成了用户信息就变成了Spring social框架:
    Spring social: 把下面的流程封装到了SocialAuthenticationFilter中, 当请求来时, 在这个过滤器里实现了第三方登陆

步骤:
	0. 用户访问client
	1. 将用户导向认证服务器(访问服务器的url, 与第三步的url是一样的)
	2. 用户同意授权
	3. 服务提供商携带授权码返回client(返回的url地址就是回调地址, 在申请qq登录时, 需要填写一个回调域)
	4. client向服务提供商申请令牌
	5. 服务提供商发放令牌
	6. client拿着令牌向服务提供商获取用户信息
	7. 与服务提供商无关, client根据用户信息, 构建Authentication, 并放入SecurityContext中. 实际上就是完成了登录

	综述: 
		1. 开发ServiceProvider, 需要getUserInfo()的Api类和OAuth2Template(封装前五步)
		2. 用ConnectionFactory创建Connection类, 来封装社交登录后获得的用户信息, 
		3. 期间需要调用ApiAdaptor,把不同应用在第六步获得的数据结构不同的用户信息适配转化成相同的Connection类封装用户信息, 然后存在数据库UserConnection表中
		4. 构建出Authentication对象, 实现登录.

Spring social框架: 封装的是client的行为
Spring security OAuth框架: 封装的是服务提供商的行为, 来发令牌等
    -- 认证服务器(通过4种标准授权模式确认用户身份和权限(提供了默认实现),或者使自定义的认证方式(手机号, 社交账号等), 然后调用Token生成机制发给client,来实现Token的生成和存储(提供了默认的实现))
    -- 资源服务器(保护rest服务, 做法是在spring security过滤器链上加了一个OAuth2AuthenticationProcessingFilter, 作用是从请求中拿出token, 根据token的存储策略, 根据Token找到用户信息, 进行判断, 然后访问rest服务)

JWT(json web token)
    自包含: 令牌中包含有意义信息, 不需要到数据库等中读取令牌拿到有意义的信息
    密签: 虽然大家都看得到JWT, 所以不要放敏感信息, 但是发出的令牌可以签名, 防止篡改
    可扩展: 有意义的信息是可以扩展的		


三种用户认证的方式
1. 借助于传统的Servlet容器的cookie-session机制
2. 借助外部存储redis实现的token机制, 但要依赖外部redis, 可以实现单点登录
3. 借助JWT, 将用户信息直接存在JWT中, 避免对外部存储设备redis的依赖

JWT: (引入java-jwt的依赖)
	Header
	PayLoad
	Signature

JWT的缺陷是, 一开始创建时就定死了有效期, 但用户的登出是随机的, 所以还是需要借助redis, 修改其有效时间

public class JwtHelper {

    private static final String SECRET = "session_secret";

    //发布者, 可以一起校验
    private static final String ISSUER = "mooc_user";

    public static String genToken(Map<String, String> claims) {
        try {
            Algorithm algorithm = Algorithm.HMAC256(SECRET);
            JWTCreator.Builder builder = JWT.create().withIssuer(ISSUER)
                    //过期时间
                    .withExpiresAt(DateUtils.addDays(new Date(), 1));
            //将参数claims, 也就是要存入jwt token的那些属性, 存入token中
            claims.forEach((k, v) -> builder.withClaim(k, v));
            //做一个签名算法
            return builder.sign(algorithm).toString();
        } catch (IllegalArgumentException | UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
    }

    public static Map<String, String> verifyToken(String token) {
        Algorithm algorithm = null;
        try {
            algorithm = Algorithm.HMAC256(SECRET);
        } catch (IllegalArgumentException | UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        JWTVerifier verifier = JWT.require(algorithm).withIssuer(ISSUER).build();
        DecodedJWT jwt = verifier.verify(token);
        Map<String, Claim> map = jwt.getClaims();
        Map<String, String> resultMap = Maps.newHashMap();
        map.forEach((k, v) -> resultMap.put(k, v.asString()));
        return resultMap;
    }
}

在UserService中

/**
	* 校验用户名密码、生成token并返回用户对象
	*
	* @param email
	* @param passwd
	* @return
	*/
public User auth(String email, String passwd) {
	if (StringUtils.isBlank(email) || StringUtils.isBlank(passwd)) {
		throw new UserException(Type.USER_AUTH_FAIL, "User Auth Fail");
	}
	//先构造一个用户对象, 作为查询条件
	User user = new User();
	user.setEmail(email);
	user.setPasswd(HashUtils.encryPassword(passwd));
	user.setEnable(1);
	//开始查询用户
	List<User> list = getUserByQuery(user);
	if (!list.isEmpty()) {
		User retUser = list.get(0);
		//查到登录的用户后, 生成token, 存JWT
		onLogin(retUser);
		return retUser;
	}
	throw new UserException(Type.USER_AUTH_FAIL, "User Auth Fail");
}

private void onLogin(User user) {
	String token = JwtHelper.genToken(ImmutableMap.of("email", user.getEmail(), "name", user.getName(), "ts", Instant.now().getEpochSecond() + ""));
	renewToken(token, user.getEmail());
	user.setToken(token);
}