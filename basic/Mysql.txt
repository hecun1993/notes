select ... for update 是悲观锁: 使用InnoDB引擎
在明确主键, 而且有结果集的情况下, 才会产生行锁, 否则就是表锁

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 
right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

explain显示了MySQL如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。(key)

只有几个值的字段如性别并且数据分布比较均匀，查询的平均命中率要是非常高就不需要建立索引，

聚集索引和非聚集索引
	聚集索引表示表中存储的数据按照索引的顺序存储，检索效率比非聚集索引高，但对数据更新影响较大。
		聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。
		聚集索引可以创建在任何一列你想创建的字段上
	非聚集索引表示数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置，非聚集索引检索效率比聚集索引低，但对数据更新影响较小。

	索引是通过二叉树的形式进行描述的，我们可以这样区分聚集与非聚集索引的区别：聚集索引的叶节点就是最终的数据节点，而非聚集索引的叶节仍然是索引节点，但它有一个指向最终数据的指针。

联合索引:
	Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。
	从左到右来组合.


mysql安全：权限, 防止sql注入(预编译绑定变量)
	1. 防止sql注入，对特殊字符转义，使用预编译绑定变量
	2. 最小权限，为不同类型的动作组件不同的用户
	3. 当sql运行出错的时候，不要把数据库返回的错误信息全部显示给用户

mysql索引：
	* 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用，指向数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构就是索引。
	* 为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

	1. 在哪些列上加索引：
		经常搜索
		作为主键的列
		经常连接
		经常需要根据范围查询(已排序，指定的范围是连续的)
		经常需要排序
		经常使用where
	
	2. 不要加索引的列
		* 当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的
		* text image不要加索引

	3. 普通索引（key或index）唯一作用是加快对数据的访问速度。普通索引允许被索引的数据包含重复的值。如果确定某个数据列只包含不相同的值，则创建索引的时候，要加unique key。-- 可以保证数据记录的唯一性。

	4. 主键索引是一种特殊的唯一索引，一张表中只能定义一个主键索引。primary key

	5. index索引，也就是联合索引，可以覆盖多个数据列。

myisam和innodb的区别：
	innodb支持事务，支持行级锁（基于索引实现行级锁），支持外键，不支持全文索引.
	myisam不支持事务，支持表级锁，不支持外键，支持全文索引

	innodb可以插入缓冲，可以预读。有错误日志，查询日志，慢查询日志...
	myisam内部维护了一个计数器，select count(*)更快

	insert17条记录之后，删除15，16，17，重启mysql，再次insert。innodb是15，因为innodb把自增主键的最大id记录存在内存中。myisam是18，把自增主键的最大id记录存在数据文件中。

	innodb存储容量有上限，myisam没有上限

	在索引中, Myisam存储的是存放真实数据的地址,而Innodb存储的是真实的数据。

让数据库支持emoji表情：字符集为utf8_mb4

优化sql语句
	select不用 *
	不要再where中用!=或<>, 或对某一字段进行null值判断, 否则会放弃索引而进行全表扫描.
	针对查询较慢的语句，可以使用explain语句分析具体的执行情况

	drop直接删掉表 
	truncate删除表中数据，再插入时自增长id又从1开始 
	delete删除表中数据，可以加where字句。

外键：在一个表中存在的另一个表的主键称此表的外键。

int（20）中20的涵义: 表示最大显示宽度为20，但仍占4字节存储，存储大小不变；
char是一种固定长度的类型，varchar则是一种可变长度的类型
varchar(50)中50的涵义：最多存放50个字符
varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存

mysql索引的数据结构: 要尽量减少查找过程中磁盘I/O的存取次数。
	1. mysql的索引主要是基于Hash表或是B+树.
	2. 数据库使用树型结构增加查询效率, 但不采用复杂度为lg(N)的二叉树, 而是使用B+树.
	3. 因为, 查询索引的操作, 最耗资源的不在内存, 而是磁盘IO. 因为索引是存在磁盘上的. 当索引很大时, 无法把索引全部加入内存中. 只能一次读取一个磁盘页.
	4. 使用二叉树存储索引, 最坏的情况下, IO次数是树的高度. 而B-树和B+树比二叉树更加"矮胖".也就是说, IO次数要少, 可以提高查找性能.
	5. B+树的中间节点只存索引, 不存实际的数据, 所以, 可以存储更多的数据, 索引的树更加矮胖. B+树的数据只存在叶子节点中, 查询性能更加稳定. 而且增加了顺序访问指针, 可以提高区间访问性能.

	6. 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
	7. 预读的长度一般为页（page）的整倍数。
	8. 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。
	9. 当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。


0. 关系/非关系型数据库
	关系：
		支持事务，数据存储在二维表格中，支持复杂查询，易于维护。
		为了维护一致性，导致读写性能较差，固定表结构，更改不方便。
	非关系：
		键值对存储数据，算是一种结构化数据存储的集合。
		读写性能高，易于扩展，可存储文档，图片等基础类型之外的数据
		不提供sql支持，学习成本高。

1. 数据库三范式:
	范式就是规范,就是关系型数据库在设计表时，要遵循的三个规范。
	要想满足第二范式必须先满足第一范式，要满足第三范式必须先满足第二范式。
	1. 第一范式（1NF）(确保每列保持原子性)
		指数据库表的每一列都是不可分割的基本数据项，列数据的不可分割。
		举例：
			地址属性，如果系统会经常访问地址中的城市属性，则要把地址属性分成省和市两个数据项。这样就满足了第一范式的原子性。

	2. 第二范式（2NF）(确保表中的每列都和主键相关)
		要第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）
		举例：
			在一个订单信息表中，需要订单编号，也需要商品编号，则需要让订单编号和商品编号做联合主键。这样，有一些属性，比如商品名称，单价等就只与商品编号有关，与联合主键无关。所以，应该把表拆分成两个表，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中。

	3. 第三范式（3NF）(确保每列都和主键列直接相关,而不是间接相关)
		要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。
		举例：
			比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。

2. 事务的四大特性
	原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
	一致性：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束
	隔离性：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
	持久性：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。

3. 事务的隔离级别
	考虑有多个事务并发执行，在读取数据方面可能碰到的状况。包括脏读、不可重复读和幻读。

	脏读:
		是指在数据库访问中，事务T1将某一值修改，但还没有提交; 然后, 事务T2读取该值; 此后T1因为某种原因撤销对该值的修改; ==> 这就导致了T2所读取到的数据是无效的。
			T2: update user set age = 21 where id = 1; //21
				!但是没有commit
			T1: select age from user where id = 1; //21
			然后T2回滚，就没有21岁的数据了，所以T1读到了脏数据，就是脏读。

	不可重复读:
		是指在数据库访问中，事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，结果得到了不同的结果。
			T1: select * from user where id = 1;
			T2: update user set age = 21 where id = 1;
				commit;
			T1: select * from user where id = 1;
			!在一个事务范围(T1)内(因为T1还没有commit)，两次读取到的数据不相同。

	幻读:
		第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的“全部数据行”。同时，第二个事务向表中插入“一行新数据”。那么，操作第一个事务发现, 表中还有没有修改的数据行.　　
			T1: select * from user where age between 10 and 30;
			T2: insert into user values(3, "bob", 27);
			T1: select * from user where age between 10 and 30;

	可以在利用数据库的锁机制,或者多版本并发控制机制获取更高的隔离等级。但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。
		读未提交：脏读，不可重复读，幻读都无法解决。
		读已提交：只有在事务二提交之后，事务一才能读数据。可以解决脏读问题。
		可重复读：只有在事务二提交之后，事务一才能更改该行数据。可以解决脏读和不可重复读问题。
		串行化：解决全部脏读，不可重复读，幻读问题。

	注意: 事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。
	1.redo log
		在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。
		事务过程中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。

	2.undo log
		undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。

5. 并发问题

当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。
可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎)。
	行级锁
		行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁分为共享锁和排他锁.
		开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
	表级锁
		表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享锁与表独占写锁.
		开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
	页级锁
		页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB引擎支持页级锁.
		开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

	MyISAM和MEMORY采用表级锁
	BDB采用页面锁或表级锁，默认为页面锁
	InnoDB支持行级锁和表级锁,默认为行级锁

	注意: InnoDB行级锁都是基于索引的,只有通过索引条件检索数据，InnoDB才使用行级锁. 如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁。

	行级锁和死锁：
		MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

共享锁和排它锁：
	共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。
		SELECT ... LOCK IN SHARE MODE;
	排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。
		SELECT ... FOR UPDATE;

乐观锁与悲观锁：
	
悲观锁：
	正如其名，它指的是对数据被外界修改持保守态度，在整个数据处理过程中，将数据处于锁定状态。 
	悲观锁的实现，往往依靠数据库提供的锁机制 

	操作过程：
		在对任意记录进行修改前，先尝试为该记录加上排他锁
		如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。	
		如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
		其间如果有其他对该记录做修改或加排他锁的操作，都会等待解锁或直接抛出异常。
	InnoDB中使用悲观锁
		要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit = 0;

乐观锁：
	1. 乐观锁假设并发操作数据一般情况下不会造成冲突，所以，只有在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。
	2. 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。
		数据版本是为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
		当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为有别的线程修改过数据。
	实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。
	使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号.

6. 存储过程
	1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。
	2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。
	3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。
	4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。

	create procedure insert_Student (_name varchar(50),_age int ,out _id int)
	begin
		insert into student value(null,_name,_age);
		select max(stuId) into _id from student;
	end;

	call insert_Student('wfz',23,@id);
	select @id;

7. 连接池
	1. 限定数据库的个数，不会导致由于数据库连接过多导致系统运行缓慢或崩溃
	2. 数据库连接不需要每次都去创建或销毁，节约了资源, 响应时间更快。

8. JDBC中的PreparedStatement相比Statement的好处
	1：PreparedStatement是预编译的，比Statement速度快 
	2：代码的可读性和可维护性
	3：安全性:PreparedStatement可以防止SQL注入攻击，而Statement却不能。



查看表结构：describe 表名;

java-Long / mysql-bigint(20)
java-BigDecimal / mysql-decimal(20,2)
java-Date / mysql-datetime

1. 占用存储空间不同。timestamp储存占用4个字节，datetime储存占用8个字节
2. 可表示的时间范围不同。timestamp可表示范围:1970-01-01 00:00:00~2038-01-09 03:14:07，datetime支持的范围更宽1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
3. 索引速度不同。timestamp更轻量，索引相对datetime更快。
4. TIMESTAMP类型在默认情况下，insert、update 数据时，TIMESTAMP列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新。默认情况下以后任何时间修改表中的记录时，对应记录的timestamp值会自动被更新为当前的系统时间。
datetime允许为空值，可以自定义值，系统不会自动修改其值。

修改自动更新：
`field_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE
修改不自动更新
`field_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP 

结论：
	timestamp类型适合用来记录数据的最后修改时间，因为只要你更改了记录中其他字段的值，timestamp字段的值都会被自动更新。（如果需要可以设置timestamp不自动更新）
	datetime类型适合用来记录数据的原始的创建时间，因为无论你怎么更改记录中其他字段的值，datetime字段的值都不会改变，除非你手动更改它。

select longtitude, latitude, count(1) from stat group by longtitude, latitude;

select current_timestamp() from dual;

select unix_timestamp(now()) from dual;

select current_timestamp - interval 10 minute from dual;

select unix_timestamp(data_sub(sysdate(), interval 10 minute)) from dual;

select unix_timestamp(data_sub(current_timestamp(), interval 10 minute)) from dual;

select unix_timestamp(data_sub(current_timestamp(), interval 10 minute)) * 1000 from dual;

select longtitude, latitude, count(1) from stat where time > unix_timestamp(data_sub(current_timestamp(), interval 10 minute)) * 1000 group by longtitude, latitude;

DataSource在jdk7之后, 不需要手动关闭了.

PrepareStatement:
	execute()主要用在ddl语句, 也就是建表语句中
	executeUpdate()主要用在dml语句, 也就是insert update delete语句中, 返回值是影响的行数