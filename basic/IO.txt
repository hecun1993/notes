对设备的读操作是将数据从Linux的内核空间复制到用户空间；
写操作是将数据从Linux的用户空间复制到内核空间。


典型NIO有三类线程，分别是mainReactor线程、subReactor线程、work线程。
    mainReactor线程负责监听server socket，accept新连接，并将建立的socket分派给subReactor；
    subReactor可以是一个线程，也可以是线程池（一般可以设置为CPU核数），负责多路分离已连接的socket，读写网络数据，这里的读写网络数据可类比顾客填表这一耗时动作，
    对具体的业务处理功能，其扔给worker线程池完成。

NIO和IO
	NIO是面向缓冲的, 非阻塞的, 有选择器
	IO是面向流的, 阻塞的, 无选择器
	1. IO是面向流的，无法前后移动流中的数据. NIO是面向缓冲区的, 增加数据处理的灵活性
	2. IO的各种流是阻塞的。NIO的非阻塞模式.
	3. NIO只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。

InputStream, OutputStream -- 处理字节流的抽象类
	我们使用的是: FileInputStream FileOutputStream.

Reader, Writer -- 处理字符流的抽象类
	我们使用的是: InputStreamReader OutputStreamWriter
	它们可以实现字节流和字符流之间的互相转化

BufferedReader, BufferedWriter -- 缓冲方式的读取
	readLine 读取一个文本行

new BufferedReader(new InputStreamReader(new FileInputStream(new File("test.txt")), "utf8"));
new BufferedReader(new FileReader("test.txt"))

	int i;
	while((i = fis.read()) != -1){
		System.out.println(i);
	}
	
	String line;
	while((line = br.readLine()) != null){     
		System.out.println(line);     
	}

IO通信对比：
	客户端个数：
		BIO   1:1
		伪异步IO  M:N
		NIO  M:1
		MIO  M:0

  	类型：
		BIO 阻塞同步
		伪异步IO 阻塞同步
		NIO 非阻塞同步
		AIO 非阻塞异步

 	使用难度：BIO<伪异步IO<AIO<NIO
	调试难度：BIO<伪异步IO<NIO 约= AIO
	可靠性：BIO<伪异步IO<NIO 约= AIO
	吞吐量：BIO<伪异步IO<NIO 约= AIO
