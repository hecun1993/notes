服务器的线程模型:
	1、收到一个请求就处理，这个时候就不能处理新的请求，这种为阻塞
		单线程模型，无法并发，一个请求没处理完服务器就会阻塞，不会处理下一个请求。一般的服务器不会使用这种方式实现

	2、收到一个请求就新开一个线程去处理任务，主线程返回，继续处理下一个任务，这种为非阻塞
	    它也是阻塞的, 相对第一个模型来说，它解决了主线程阻塞的问题，有了一定程度的并发量.
        但是在每个新开的线程中还是阻塞的。如果100个人同时访问，将会开100个线程. 频繁开关线程很消耗资源，这样实现的服务器性能依然不高。

	3、类似2的模型，但是不是每次收到请求就开一个新的线程，而是使用线程池
	    类似于数据库连接池, 由于频繁创建、关闭数据库连接会消耗资源，所以会用它来保存一定数量的连接，如果需要就从连接池里取连接，不需要则放回连接池，不在频繁创建。
        线程池管理多线程，性能比频繁创建线程高得多。这种方式实现的服务器性能会比2高。不过，它依然是阻塞的。线程池的线程数量通常有限制的，如果所有线程都被阻塞（例如网速慢，或者被人恶意占用连接），那么接下来的请求将会排队等待。

	4、基于Java NIO实现的服务器模型
	    上面说到的几种模型，都是基于BIO（阻塞IO）。
        NIO则是非阻塞IO，它是基于IO多路复用技术（例如Reactor模式）实现，只需要一个线程或者少量线程，就可以处理大量请求。
        从性能上来说NIO实现的服务器并发性一般大于BIO，所以可以实现高性能的服务器。

	最后，Tomcat运行可以选择BIO或者NIO模型，原理分别对应上面的3和4两种方式。
    Tomcat默认是BIO方式运行，如果想要换成NIO，可以配置server.xml：
        <Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" .../>

TCP是如何保证可靠性的:
	TCP提供一种面向连接、可靠的字节流服务。 
	使用TCP的应用（服务端和客户端）在彼此交换数据之前必须先建立一个TCP三次握手连接。
    在一个TCP连接中，仅有两方进行彼此通信。注意, 广播和多播不能用于TCP。

	TCP通过以下方式来提供可靠性： 
		1》将数据截断为合理的长度: 
            应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，应用程序产生的数据报长度将保持不变
		2》超时重发: 
            当TCP发出一个段后，它启动一个定时器。等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 
		3》收到确认:
            当TCP收到发自TCP连接另一端数据，它将发送一个确认。不是立即发送，通常推迟几分之一秒用来对包的完整性进行校验。 
		4》数据段正确性检测:
            TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
            校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据 
		5》失序数据段重新排序:
            既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 
		6》丢弃重复数据:
            既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
		7》流量控制:
            使用可变大小的滑动窗口协议提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

在浏览器中输入网站域名并按下回车:
	1 DNS解析，获取Web服务器IP
		请求方按照以下顺序进行DNS解析：
	　　（1）浏览器缓存
	　　（2）系统缓存
	　　（3）路由器缓存
	　　（4）ISP DNS服务器缓存
	　　（5）根域名服务器
	　　如果第（5）步也找不到域名，则该域名不存在。

	2 建立TCP连接
	3 向Web服务器发送HTTP请求
	4 Web服务器收到请求并处理
	5 Web服务器返回响应
	6 浏览器对响应解码，并显示数据
	7 页面显示完成后，浏览器发送异步请求
	8 关闭TCP连接

socket: ip + port + 协议
socket主要用于编写网络上传输数据的程序, socket提供了一组函数，如建立连接、收发数据等等

网络模型:
	(物数网传会表应)
	1. 物理层：
		主要定义物理设备标准，如网线和光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫比特。
 	2. 数据链路层：
		主要将从物理层接收的数据进行MAC地址的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。 
	3. 网络层：
		主要将从下层接收到的数据进行IP地址的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包 
	4. 传输层：
		定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 
	5. 会话层：
		通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）
 	6. 表示层：
		主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 
	7. 应用层： 
		主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（可以把它理解成我们在电脑屏幕上可以看到的东西．就是终端应用）。

TCP/IP网络模型
	链路层：
		链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。
	网络层：
		网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。
	传输层：
		主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。
	应用层：
		主要负责应用程序的协议，例如HTTP协议、FTP协议等。

网络编程
	1.三要素
		1.IP地址(计算机网络中每台计算机的唯一标识)
			1.IP地址的组成：网络号段+主机号段
				A类：第一号段为网络号段+后三段的主机号段
					一个网络号：256*256*256 = 16777216
				B类：前二号段为网络号段+后二段的主机号段
					一个网络号：256*256 = 65536
				C类：前三号段为网络号段+后一段的主机号段
					一个网络号：256
			2.IP地址的分类：
				A类 1.0.0.1---127.255.255.254	
					(1)10.X.X.X是私有地址(私有地址是在互联网上不使用，而被用在局域网络中的地址)	
					(2)127.X.X.X是保留地址，用做循环测试用的。
				B类	128.0.0.1---191.255.255.254	
				C类	192.0.0.1---223.255.255.254	
					(1)192.168.X.X是私有地址(私有地址就是在互联网上不使用，而被用在局域网络中的地址)	
				---不常见---
				D类	224.0.0.1---239.255.255.254 	
				E类	240.0.0.1---247.255.255.254
			3.特殊:
				x.x.x.255 广播地址
				x.x.x.0 网络地址
				IPV4用4个字节表示IP地址
				IPV6用16个字节表示IP地址
		2.端口号(进程的信息)
			通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。
			在计算机中，不同的应用程序是通过端口号区分的。
			端口号是用两个字节（16位的二进制数）表示的，它的取值范围是0~65535.
				其中，0~1023之间的端口号用于一些知名的网络服务和应用
				用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。
		3.协议：通信的规则
			1.TCP：传输控制协议,是面向连接的流传输控制协议.
				具有高可靠性，确保传输数据的正确性，有验证重发机制，因此不会出现丢失或乱序。
					在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过三次握手。
						第一次握手，客户端向服务器端发出连接请求，等待服务器确认，
						第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求，
						第三次握手，客户端再次向服务器端发送确认信息，确认连接。
				由于TCP协议的面向连接特性，它可以保证传输数据的安全性，例如在下载文件时，如果数据接收不完整，将会导致文件数据丢失而不能被打开，因此，下载文件时必须采用TCP协议。
				在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。

			2.UDP：用户数据报协议,是无连接的数据报服务.
				不对数据报进行检查与修改，无须等待对方的应答，会出现分组丢失、重复、乱序，但具有较好的实时性
				在数据传输时，数据的发送端和接收端不建立逻辑连接。
					简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。
				由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议.
					因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。
				UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“集装箱”进行打包.
					JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，用于封装UDP通信中发送或者接收的数据。DatagramSocket就是码头。

			3.区别:
				UDP段结构比TCP的段结构简单，因此网络开销也小。
				UDP中只有发送端和接收端，不区分客户端与服务器端，计算机之间可以任意地发送数据。
				TCP通信是严格区分客户端与服务器端的，在通信时，必须先由客户端去连接服务器端才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。

				TCP/UDP协议都在传输层,出现TCP三次握手的原因是,网络层与硬件联系紧密,很不稳定.
	
	2.socket套接字
		网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。
		Socket原理机制：
			通信的两端都有Socket。
			网络通信其实就是Socket间的通信。
			数据在两个Socket间通过IO传输。

        传统的socket通信过程
		    创建ServerSocket对象, 绑定ip地址和端口, 然后构造while(true)循环, 调用accept()方法接收客户端的连接请求, 也就是Socket, 然后就可以开始一个线程执行任务, 比如读取客户端发来的数据

	3.TCP的连接和断开过程: 三次握手和四次握手
		ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。
		TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不会被释放。
		1. 三次握手建立连接
			C:	SYN = 1 seq = i 发送SYN = 1的数据段,序号为i
			S:	SYN = 1 seq = j ACK = 1 ack = i + 1 回复确认ACK = 1,确认号为i + 1, 发送SYN = 1的数据段,序号为j  
			C:	ACK = 1 seq = i + 1 ack = j + 1 回复确认ACK = 1, 确认序号为j + 1
			首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。
			【注意】中断连接端可以是Client端，也可以是Server端。

		2. 四次握手释放连接
			1. Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以Server端先发送ACK, "Server端告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"
			2. Client端进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"
			3. Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK, 则可以重传。"
			4. Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后, 依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
		
		3. 两个问题
			【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？
			答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。
				但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"
				只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
			【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？
			答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。

        三次握手时要是服务端的服务没开TCP协议栈怎么处理？
	        客户端会尝试三次SYN请求，服务器响应三次RST，然后结束连接

		4. 长短连接
			长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接。
			短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接，即每次TCP连接只完成一对消息的发送。

			什么是Keep-Alive模式？
				HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；
                当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
				http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。

	滑动窗口: 
		在TCP协议中使用,用于流量控制,拥塞控制等. 
		维持发送发/接收方的缓冲区,缓冲区就是用来解决网络传输中不可靠的问题.
			原来:发送包1 等待确认包1 发送包2 等待确认包2
			改进:两个包一起发送 等待两个包确认
			比如窗口大小是7,则时刻有7个包处于已发送未ack+待发送未ack的状态

			当已发送未ack的包的数量达到窗口数量,则等待,如果一直没有ack,则超时重传.
			对方应答ack包一定是按照顺序的.
        
        “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；
        “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。
	    每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送

    TCP的流量控制和拥塞控制:
        利用滑动窗口实现流量控制
            如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。
        拥塞控制：
            防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。
        区别:
            流量控制解决的只是过快的发送方的问题，根据得到ACK确认来调整发送速率，对于未收到的包再重传。这里考虑的只是一组端到端的情况.
            拥塞控制除了考虑一组发送端和接收端，共享一个路由的其他发送端和接收端也会对该组网络通信造成影响，路由的决定权（缓存大小）也是很重要的

进程间通信的方式
	主要包括管道，系统IPC(包括消息队列，信号量，共享内存)，SOCKET，RPC，Restful
	
	管道：
		普通管道：半双工，只能单向传输；只能在父子进程间使用
		流管道：可以双向传输
		命名管道：可以在许多不相关的进程之间通信

	系统IPC：消息队列，信号量，共享内存等都使用了内核里的标识符来识别
		信号量：
			用于通知某个接收进程某个事件已经发生
		消息队列：
			是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
		共享内存：
			是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
	SOCKET:
		可以用于不同主机进程间的通信

	管道的优点在于，所有的UNIX都支持，并且在最后一个访问管道的进程终止后,管道就被完全删除; 缺陷是管道只允许单向传输或者用于父子进程之间.

	系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是关键字KEY_T使用了内核标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.

进程调度算法
	1. 时间片轮转调度算法
	2. 先来先服务调度算法
	3. 优先级调度算法
	4. 多级反馈队列调度算法
		将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。
	5. 高响应比优先调度算法
		响应比 =（进程执行时间 + 进程等待时间）/ 进程执行时间，谁大谁先执行

#### TCP/IP HTTP Socket:

1. 网络由下往上分为: 物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。　　

2. IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性. socket则是对TCP/IP协议的封装和应用(程序员层面上)。　　

3. 也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输. 而HTTP是应用层协议，主要解决如何包装数据。　　

4. 我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容. 如果想要使传输的数据有意义，则必须使用到应用层协议。　　

应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上　　

socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。通过Socket，我们才能使用TCP/IP协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象