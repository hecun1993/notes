定义：
1. 是一个基于强大的Spring框架的、推崇JavaConfig的极简配置的web开发框架；
2. Spring Boot通过内嵌Servlet容器（Tomcat、Jetty，等等）的方式，可以以jar包的形式独立运行一个web项目；
3. Spring Boot提倡JavaConfig和注解的零配置方式，并且默认配置满足绝大多数场景的需要，意味着少量修改默认配置即可快速搭建一个web项目，极大的提高开发效率；
4. 项目中加入某一个spring-boot-starter-*依赖，就可以引入该功能的完整jar包，降低pom的复杂度

启动类上的注解@SpringBootApplication包含的子注解信息：
1. @SpringBootConfiguration实际上就是@Configuration，说明这是一个JavaConfig
2. @ComponentScan，启用注解自动扫描
3. @EnableAutoConfiguration的作用是根据类路径中jar包是否存在来决定是否开启某一个功能的自动配置，比如，我们项目中添加了spring-boot-starter-web依赖，因其关联Tomcat和Srping MVC，所以类路径下就会存在Tomcat和Spring MVC的jar包，SpringBoot项目扫描到这些jar包后会自动开启两者的配置，当然，这个配置是默认配置，我们可以根据需要进行修改
4. exclude和excludeName用于关闭指定的自动配置，比如关闭数据源相关的自动配置
@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
5. spring-boot-autoconfigure-1.4.2.RELEASE.jar中就有一个spring.factories，可以看到org.springframework.boot.autoconfigure.EnableAutoConfiguration参数中列出了自动配置类列表

@AliasFor注解，来给注解的属性起别名，让使用注解时，更加的容易理解（比如给value属性起别名）

@MainBean(beanName = "mainbean")  
public class Main {  
  
    public static void main(String[] args) {  
        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(Main.class);  
  
        String[] beannames = context.getBeanNamesForType(Main.class);  
  
        //当加上@AliasFor时, 输出"mainbean"  
        //当去掉@AliasFor注解后, 输出"main"  
        System.out.println(beannames[0]);  
  
        context.close();  
    }  
}  
  
@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
@Configuration  
@interface MainBean {  
  
    @AliasFor(annotation = Component.class, attribute = "value")  
    String beanName() default "";  
}  

SpringBoot的启动过程
1. SpringBoot的启动过程中，需要调用SpringApplication类的静态方法run(). 这个run方法的返回值，是ApplicationContext接口的实现类。（SpringBoot的启动过程，实际上就是对ApplicationContext的初始化过程）
2. 所以，我们需要首先创建SpringApplication对象。也就是调用其构造方法，在构造方法中传入一些初始化参数。比如是否开启日志等。然后调用其构造函数中的initialize方法。在initialize方法中，有四点需要注意。
2.1 会找到声明的所有ApplicationContextInitializer的实现类并将其实例化。
ApplicationContextInitializer是Spring框架中的接口，其作用可以理解为在ApplicationContext执行refresh之前，调用ApplicationContextInitializer的initialize()方法，对ApplicationContext做进一步的设置和处理。
2.2 找到声明的所有ApplicationListener的实现类并将其实例化。
ApplicationListener是Spring框架中的接口，就是事件监听器，其作用可以理解为在SpringApplicationRunListener发布通知事件时，由ApplicationListener负责接收。
2.3 获得当前执行main方法的类对象，这里就是SpringBootWebDemoApplication的实例。
2.4 判断当前是否是web环境。
3. 当创建好SpringApplication对象后，就要调用其run方法，来产生ApplicationContext接口的实现类了。这个过程主要包括以下步骤
ApplicationContext创建后立刻为其设置Environment，并由ApplicationContextInitializer对其进一步封装。
通过SpringApplicationRunListener在ApplicationContext初始化过程中各个时点发布各种广播事件，并由ApplicationListener负责接收广播事件。
初始化过程中完成IoC的注入，包括通过@EnableAutoConfiguration导入的各种自动配置类。
初始化完成前调用ApplicationRunner和CommandLineRunner的实现类。

SpringBootServletInitializer（用在打成war包，发布到tomcat中）
1. 将项目的启动类Application.java继承SpringBootServletInitializer并重写configure方法
2.  SpringBootServletInitializer就是一个org.springframework.web.context.WebApplicationContext，容器启动时会调用其onStartup(ServletContext servletContext)方法
3. SpringBootServletInitializer的执行过程，简单来说就是在其onStartup方法中调用createRootApplicationContext方法，通过SpringApplicationBuilder构建并封装SpringApplication对象，并最终调用SpringApplication的run方法的过程。

ServletContainerInitializer  在启动容器时负责加载相关配置
public abstract interface ServletContainerInitializer {
	public abstract void onStartup(Set<Class<?>> paramSet, ServletContext paramServletContext) throws ServletException;
}
容器启动时会自动扫描当前服务中ServletContainerInitializer的实现类（SpringServletContainerInitializer），并调用其onStartup方法，其参数Set<Class<?>> c。
@HandlesTypes注解（加在了SpringServletContainerInitializer上）会自动扫描项目中所有的WebApplicationInitializer.class的实现类，并将其全部注入Set中，完成初始化注入配置。

而正好SpringBootServletInitializer是WebApplicationInitializer的实现类，所以，打成war包的时候，需要启动类继承自SpringBootServletInitializer，方可正常部署至常规tomcat下，其主要能够起到web.xml的作用，注入一些filter，listener的配置。

ApplicationContext：

1. ApplicationContext是一个接口，是BeanFactory的一个派生类。提供了更多面向实际应用的功能。

2. ApplicationContext的主要实现类是ClassPathXmlApplicationContext和FileSystemXmlApplicationContext，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件。

ApplicationContext ctx = new ClassPathXmlApplicationContext("com/baobaotao/context/beans.xml")
ApplicationContext ctx = new FileSystemXmlApplicationContext("com/baobaotao/context/beans.xml");

3. 在获取ApplicationContext实例后，就可以像BeanFactory一样调用getBean(beanName)返回Bean了。

4. ApplicationContext的初始化和BeanFactory有一个重大的区别：BeanFactory在初始化容器时，并未实例化Bean，直到第一次访问某个Bean时才实例目标Bean；而ApplicationContext则在初始化应用上下文时就实例化所有单实例的Bean。因此ApplicationContext的初始化时间会比BeanFactory稍长一些，不过稍后的调用则没有"第一次惩罚"的问题。

5. WebApplicationContext是继承了ApplicationContext接口的接口，专门为Web应用准备。它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用。整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。

6. Spring专门为此提供一个工具类WebApplicationContextUtils，通过该类的getWebApplicationContext(ServletContext sc)方法，即可以从ServletContext中获取WebApplicationContext实例。

7. 由于Web应用比一般的应用拥有更多的特性，因此WebApplicationContext扩展了ApplicationContext。WebApplicationContext定义了一个常量ROOT_WEB_APPLICATION_ CONTEXT_ATTRIBUTE，在上下文启动时，WebApplicationContext实例即以此为键放置在ServletContext的属性列表中，因此我们可以直接通过以下语句从Web容器中获取WebApplicationContext：
WebApplicationContext wac = (WebApplicationContext)servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
这正是我们前面所提到的WebApplicationContextUtils工具类getWebApplicationContext （ServletContext sc）方法的内部实现方式。这样Spring的Web应用上下文和Web容器的上下文就可以实现互访，二者实现了融合。

8. WebApplicationContext的初始化方式和BeanFactory、ApplicationContext有所区别，因为WebApplicationContext需要ServletContext实例，也就是说它必须在拥有Web容器的前提下才能完成启动的工作。

9. ServletContext是一个全局的储存信息的空间，服务器开始，其就存在，服务器关闭，其才释放。request，一个用户可有多个；session，一个用户一个；而servletContext，所有用户共用一个。所以，为了节省空间，提高效率，ServletContext中，要放必须的、重要的、所有用户需要共享的线程又是安全的一些信息。

10. ServletContext被Servlet程序用来与Web容器通信。例如写日志，转发请求。每一个 Web 应用程序含有一个Context，被Web应用内的各个程序共享。因为Context可以用来保存资源并且共享，所以我所知道的 ServletContext 的最大应用是Web缓存----把不经常更改的内容读入内存，所以服务器响应请求的时候就不需要进行慢速的磁盘I/O了。

11. 上下文的作用 
web容器在启动时，它会为每个web程序都创建一个对应的ServletContext对象，它代表当前的web应用。 事实上SpringMVC封装的ApplicationContext  以及Struts2封装的ApplicationContext里面都是保存着原本的ServletContext作用：Web应用范围内存取共享数据；访问web应用的静态资源；Servlet对象之间通过ServletContext对象来实现通讯。

final ServletContext application = request.getServletContext();

ServletContext application=this.getServletContext();
application.setAttribute("name","value");
application.getAttribute("name");

可以把他想象成是一个共用的空间，可以被所有的用户访问，也就是说，A客户可以访问D,B，C也是可以的。即有些数据是被各个用户共享的。

Session和ServletContext 的区别  
使用不同浏览器访问的时候 ServletContext还是可以访问到，Session是不能访问到的。

12. 使用ContextLoaderListener启动WebApplicationContext
在web.xml中配置Web容器监听器（ContextLoaderListener），可以完成启动Spring Web应用上下文的工作。

<!--①指定配置文件--> 
<context-param>                                                        
     <param-name>contextConfigLocation</param-name>   
     <param-value> 
       /WEB-INF/baobaotao-dao.xml, /WEB-INF/baobaotao-service.xml  
     </param-value> 
</context-param> 
<!--②声明Web容器监听器--> 
<listener>   
     <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class> 
</listener> 

ContextLoaderListener通过Web容器上下文参数contextConfigLocation，获取Spring配置文件的位置。用户可以指定多个配置文件，用逗号、空格或冒号分隔均可。

Spring Boot打包方式

1. 如果是多模块应用，提示找不到主类，需要把build节点的信息放在web模块（核心模块）中，同时添加主类信息
2. 多模块应用，主模块可以删掉src文件夹，要注意不同模块之间的依赖关系
3. 如果打包方式是war，则需要添加webapp/WEB-INF/web.xml

<build>
	<plugins>
        <plugin>
            <grounpId>org.spring.framework.boot</grounpId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <mainClass>com.imooc.firstappdemo.FirstAppDemoApplication</mainClass>
            </configuration>
        </plugin>
    </plugins>
</build>

spring boot自动加载的源码分析
	1.RedisProperties -> RedisConnectionConfiguration -> RedisAutoConfiguration
	2.SpringApplication对象被实例化 -> 加载spring.factories文件

	- 比如在主配置文件application.yml中配置了redis的配置项
	- spring.redis.port = 6379
	- 则首先会有RedisProperties类从配置文件中读取到这些属性，然后封装成RedisProperties类
	- 接着，这个类会变成RedisConnectionConfiguration类的一个属性，而这个RedisConnectionConfiguration类又会成为RedisAutoConfiguration类的一个属性。
	- 这样，就会自动配置redis了。
	- springboot启动的时候，会实例化SpringApplication对象，在这个过程中，会加载META-INF/spring.factories文件，在这个文件中定义了类似于RedisAutoConfiguration等一系列的类，这些类都会被加载到spring容器中。

1. 命令行启动: java -jar target/xx.jar -Dmaven.skip.test=true --spring.profiles.active=prod
	
3. pom.xml
	在pom文件中引入spring-boot-starter-parent，可以提供依赖管理，在申明其他依赖的时候，可以不需要添加版本号。

4. @SpringBootApplication = @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan
	- 该注解相当于三个注解
	- @SpringBootConfiguration: 将该类作为springboot的配置文件类
	- @EnableAutoConfiguration: 程序启动时，自动加载springboot默认的配置
	- @ComponentScan: 程序启动时，自动扫描当前包及子包下的所有类
	
@DateTimeFormat
	@RequestParam("start") @DateTimeFormat(pattern="yyyy-MM-dd hh:mm:ss") Date start,
		前端传入的参数是字符串，但service的方法需要的数据类型是Date类型，可以加注解解决：

SpringBoot默认Servlet容器是基于Tomcat8的


@EnableScheduling : 开启对计划任务的支持(定时器) 

    需要有注解@Scheduled配合，类的方法中有@Scheduled注解，则该类必须加上@Component注解

    @Service
    public class ScheduledTaskService {
        private static final SimpleDateFormat dateFormat = new SimpleDateFormat("HH:mm:ss");

        @Scheduled(fixedRate = 5000) //通过@Scheduled声明该方法是计划任务，使用fixedRate属性每隔固定时间执行
        public void reportCurrentTime(){
            System.out.println("每隔5秒执行一次 "+dateFormat.format(new Date()));
        }

        @Scheduled(cron = "0 07 20 ? * *" ) //使用cron属性可按照指定时间执行，本例指的是每天20点07分执行；
        public void fixTimeExecution(){
            System.out.println("在指定时间 "+dateFormat.format(new Date())+" 执行");
        }
    }

@ModelAttribute

请求的FORM表单数据
    <form method="post" action="hao.do">
        a: <input id="a" type="text" name="a"/>
        b: <input id="b" type="text" name="b"/>
        <input type="submit" value="Submit" />
    </form>

    public class Pojo {
        private String a;
        private int b;
    }
        
    @RequestMapping(method = RequestMethod.POST) 
    public String processSubmit(@ModelAttribute("pojo") Pojo pojo) { 
        return "hello World"; 
    }

@RequestBody
    springmvc接收JSON类型的参数数据
    
    处理的是ajax提交来的json数据!!!!!
    1、常用来处理content-type是application/json类型。
    2、通过@requestBody可以将请求体中的JSON字符串绑定到相应的bean上，当然，也可以将其分别绑定到对应的字符串上。
    　　　　　　　　例如说以下情况：
    　　　　$.ajax({
    　　　　　　　　url:"/login",
    　　　　　　　　type:"POST",
    　　　　　　　　data:'{"userName":"admin","pwd","admin123"}',
    　　　　　　　　content-type:"application/json charset=utf-8",
    　　　　　　　　success:function(data){
    　　　　　　　　　　alert("request success!");
    　　　　　　　　}
    　　　　});

    　　　　@requestMapping("/login")
    　　　　public void login(@RequestBody String userName, @RequestBody String pwd){
    　　　　　　System.out.println(userName + "：" + pwd);
    　　　　}
            这种情况是将JSON字符串中的两个变量的值分别赋予了两个字符串
        
        如果有一个User类，拥有如下字段：
            String userName; String pwd;
        那么上述参数可以改为以下形式：@requestBody User user 
        这种形式会将JSON字符串中的值赋予user中对应的属性上
    　　需要注意的是，JSON字符串中的key必须对应user中的属性名，

@Autowired

    @Autowired的使用：推荐对构造函数进行注解, 而不是对成员变量进行注解

    @Autowired是根据类型注入的, @Resource是根据名字注入的

    原来是
    @Autowired
    private UserService userService;

    建议写成
    private final UserService userService;

    @Autowired
    private UserController(UserService userService) {
        this.userService = userService;
    }

    @Autowired 可以对成员变量、方法以及构造函数进行注释。原因如下:

    @Autowired
    private User user;
    private String school;

    public UserAccountServiceImpl() {
        this.school = user.getSchool();
    }

    这段代码会报错. 因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值，
    但在构造方法中要有user对象, 此时还没有注入, 所以在执行构造方法的时候，就会报错。

    改正: 使用构造器注入

    private User user;
    private String school;

    @Autowired
    public UserAccountServiceImpl(User user) {
        this.user = user;
        this.school = user.getSchool();
    }

    可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。

    Java变量的初始化顺序为：
    静态变量或静态语句块–>实例变量或初始化语句块–>构造方法–>@Autowired

    @Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，可能是为了防止，在程序运行的时候，又执行了一遍构造函数；或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。

