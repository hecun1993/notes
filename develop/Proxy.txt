JDK动态代理 对“装饰者”设计模式 简化。使用前提：必须有接口
    1.目标类：接口 + 实现类
    2.切面类：用于存通知 MyAspect
    3.工厂类：编写工厂生成代理
    4.测试

//目标类
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

//切面类
public class MyAspect {
    public void before(){
        System.out.println("鸡首");
    }
    
    public void after(){
        System.out.println("牛后");
    }
}

//工厂类
public class MyBeanFactory {
    
    public static UserService createService(){
        //1 目标类
        final UserService userService = new UserServiceImpl();
        //2 切面类
        final MyAspect myAspect = new MyAspect();
        
        /* 
         *  3 生成代理类：将目标类（切入点）和 切面类（通知） 结合 --> 切面
         *  Proxy.newProxyInstance
         *      参数1：loader，类加载器，动态代理类是在运行时创建，任何类都需要类加载器将其加载到内存。
         *          一般情况：当前类.class.getClassLoader();
         *          也可以：目标类的!实例!.getClass().getClassLoader();
         *      参数2：Class[] interfaces 代理类需要实现的所有接口
         *          方式1：目标类实例.getClass().getInterfaces();注意：只能获得自己接口，不能获得父元素接口
         *          方式2：new Class[]{UserService.class}   
         *      参数3：InvocationHandler，这是一个接口，必须进行实现类，一般采用匿名内部
         *          提供 invoke 方法，!代理类的每一个方法执行时，都将调用一次invoke!
         *              参数31：Object proxy ：代理对象
         *              参数32：Method method : 代理对象当前执行的方法的描述对象（反射）
         *                  执行方法名：method.getName()
         *                  执行方法：method.invoke(目标对象，实际参数)
         *              参数33：Object[] args :方法实际参数
         * 
         */
        UserService proxService = (UserService)Proxy.newProxyInstance(
            MyBeanFactory.class.getClassLoader(), 
            userService.getClass().getInterfaces(), 
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    
                    //前执行
                    myAspect.before();
                    
                    //执行目标类的方法，有返回值，也就是addUser的返回值，是null
                    Object obj = method.invoke(userService, args);
                    
                    //后执行
                    myAspect.after();
                    
                    //返回方法的返回值
                    return obj;
                }
            }
        );
        return proxService;
    }
}

//测试类
@Test
public void demo01(){
    UserService userService = MyBeanFactory.createService();
    userService.addUser();
    userService.updateUser();
    userService.deleteUser();
}

=======

cglib代理:
    public class MyBeanFactory {
        public static UserServiceImpl createService(){
            //1 目标类
            final UserServiceImpl userService = new UserServiceImpl();
            //2切面类
            final MyAspect myAspect = new MyAspect();
            
            // 3.代理类 ，采用cglib，底层创建目标类的子类
            //3.1 核心类
            Enhancer enhancer = new Enhancer();
            //3.2 确定父类
            enhancer.setSuperclass(userService.getClass());
            /* 3.3 设置回调函数, MethodInterceptor接口 等效 jdk中的 InvocationHandler接口
             *  intercept() 等效 jdk  invoke()
             *      参数1、参数2、参数3：和invoke一样
             *      参数4：methodProxy 方法的代理
             */
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                    //前
                    myAspect.before();
                    
                    //执行目标类的方法
                    Object obj = method.invoke(userService, args);
                    //执行代理类的父类（其实就是目标类）中的方法，和上面一行的效果等价，可以不写。
                    methodProxy.invokeSuper(proxy, args);
                    
                    //后
                    myAspect.after();
                    
                    return obj;
                }
            });
            
            //3.4 创建代理
            UserServiceImpl proxService = (UserServiceImpl) enhancer.create();
            
            return proxService;
        }
    }
