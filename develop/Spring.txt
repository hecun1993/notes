ApplicationContext和BeanFactory在获取对象的区别:
    BeanFactory factory = new XmlBeanFactory(new ClassPathResource("com/hsp/ioc/beans.xml"));
    - applicationContext: 只要我们实例化容器，那么所有的对象都会被实例化(前提是将bean配置成单例模式)
    - BeanFactory: 首先实例化该容器，容器中的对象是否立即实例化，根据配置文件的配置来进行配置。如果容器的bean配置的是不被立即实例化，那只有执行getBean去获取某个bean的时候，容器才会将对象实例化。
    - 使用applicationContext的好处就是：所有的对象都可以预加载，缺点就是消耗服务器的内存；而使用BeanFactory的话，好处是节约内存，缺点则是速度会相对来说慢一些。而且有可能会出现空指针异常的错误。而且通过bean工厂创建的bean生命周期会简单一些。
系统中通过引入实现了IOC模式的IOC容器, 即可由IOC容器来管理对象的生命周期, 依赖关系等.

Spring的IOC动态注入
    利用java里的类反射，根据在XML中定义的类名, 在运行时动态创建和生成对象,以及创建对象之间的依赖
    Spring就是在运行时，根据xml的配置文件来动态的创建对象，和调用对象里的方法的。

1.BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范,比如根据bean的名字，获取在IOC容器中得到bean实例
2. 具体的IOC容器实现，spring提供了许多IOC容器的实现。 
    XmlBeanFactory，ClasspathXmlApplicationContext
3. Bean对象在Spring实现中是以BeanDefinition来描述的

Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入

Spring源码之IoC容器的加载

- IoC容器的初始化包括三个过程，BeanDefinition的Resource的定位、载入和注册。

- 1. Resource的定位。指BeanDefinition的资源定位，通过ResourceLoader接口中的getResource方法完成。（对各种形式的BeanDefinition提供统一的接口）

- 2. BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。BeanDefinition实际上就是POJO对象在IOC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IOC容器能够方便地对POJO对象也就是Bean进行管理。

- 3. 向IOC容器注册BeanDefinition。通过调用BeanDefinitionRegistry接口的实现来完成。通过分析，在IOC容器内部将BeanDefinition注入到一个HashMap中去，IOC容器就是通过这个HashMap来持有这些BeanDefinition数据的

- 注意，在IOC设计中，Bean定义的载入和依赖注入是两个独立的过程。依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。但可以通过设置<bean lazyinit="true" />来配置。


核心
    控制反转（IoC）和切面编程（AOP）  
    依赖注入(DI)和控制反转(IOC)在spring环境下是等同的概念。控制反转是通过依赖注入实现的。

spring容器:
    创建对象
    管理依赖
    管理生命周期, 实现丰富的逻辑

依赖注入指容器负责创建对象和维护对象之间的依赖关系，而不是靠对象自己。依赖注入的主要目的是解耦，体现一种“组合”的理念。希望一个类具备某个功能，组合另外一个具有这样功能的类，比继承一个具有此功能的父类更好。

IoC负责创建Bean，并通过容器将功能类Bean注入到需要的Bean中。有xml配置，注解配置，Java配置。这些都被称为配置元数据。

优点
1. 方便解耦，简化开发（spring是一个大容器，负责创建bean，维护bean之间的依赖）
2. AOP支持（面向切面编程，权限拦截，运行监控）
3. 事务的支持
4. 方便单元测试
5. 继承各种优秀框架
6. 对JdbcTemplate等JAVAEE的API进行封装，简化使用。

spring的核心容器包括，Beans（管理bean），Core，Context，ExpressLanguage（spring的EL表达式）

依赖注入（DI）
is a ：是一个，继承。  
has a：有一个，成员变量，依赖。

class B {
    private A a;   //B类依赖A类
}

依赖：一个对象需要使用另一个对象  
注入：通过setter方法进行另一个对象实例设置。

class BookServiceImpl{
    //之前开发：接口 = 实现类  （service和dao耦合）
    //private BookDao bookDao = new BookDaoImpl();
    
    //spring之后 （解耦：service实现类使用dao接口，不知道dao接口具体的实现类）
    private BookDao bookDao;
    BookDao的setter方法
}


## AOP
#### 底层原理（BeanPostProcessor）
spring 提供一种机制，只要我们写的类实现BeanPostProcessor接口，并将实现类提供给spring容器(<bean class=""> 不需要写id)，spring容器将自动在初始化方法(init)前执行before()，在初始化方法后执行after() 

目的是修改生成的bean对象，创建代理对象，是AOP的底层。
> 这里创建的代理对象，可以在before方法中返回代理对象，也可以在after方法中返回代理对象。  

public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    	System.out.println("前方法 ： " + beanName);
    	return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
    	System.out.println("后方法 ： " + beanName);
    	// bean 目标对象
    	// 生成 jdk 代理
    	return Proxy.newProxyInstance(
            MyBeanPostProcessor.class.getClassLoader(), 
            bean.getClass().getInterfaces(), 
            new InvocationHandler(){
            	@Override
            	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    System.out.println("开启事务");
            		
                    //执行目标方法
                    Object obj = method.invoke(bean, args);
                    
                    System.out.println("提交事务");
                    return obj;
            	}
            }
        );
    }
}

AOP的概念

1. AOP指面向切面编程。通过预编译方式，或者主要是运行期间的动态代理技术来实现功能。它可以使业务逻辑各部分之间的耦合度降低，提高程序的可重用性。
2. 采取横向抽取机制，取代了传统纵向继承体系重复性代码  
具体指，比如原来要为Service中的add和delete两个方法添加事务的操作，而且不能修改原先的代码。那么我们只能另外写一个类A来继承Service类，然后分别在add和delete方法的前后，加事务开启和事务提交。  
但是，如果使用AOP，我们就可以直接写一个A类，里面是开启和提交事务的方法，然后把A类和Service全部交给Spring，让它为我们产生代理对象。  
3. 经典应用：事务管理、性能监视、安全检查、缓存 、日志等。  

第一种情况，有接口情况，使用动态代理创建接口实现类代理对象  
第二种情况，没有接口情况，使用cglib代理创建类的子类代理对象

#### 术语
    Joinpoint(连接点): 指类里面可以被增强的方法。  
    Pointcut(切入点)：指我们要进行拦截增强的那些连接点。
    Advice(通知/增强)：指对切入点所做的事情。通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)  
    Aspect(切面): 是切入点和通知的结合。 
    Weaving(织入)：把增强advice应用到目标对象target来创建新的代理对象proxy的过程。
    目标类：需要被代理的类。  
    代理类：Proxy  

=========

springmvc执行流程
    1. 每一个请求都会先发给DispatcherServlet，然后由其负责请求的分发，给相应的HandlerMapping处理器映射器，然后根据请求的url，找到对应的处理器，生成处理器对象，返回给DispatcherServlet。
    2. DispatcherServlet通过HandlerAdapter处理器适配器来调用处理器Handler, 它是继DispatcherServlet之后的后端控制器，执行处理器的业务逻辑。执行完成后，将返回ModelAndView对象给处理器适配器，然后处理器适配器再把ModelAndView返回给前端控制器。
    3. DispatcherServlet把ModelAndView传递给ViewResolver视图解析器，解析之后返回具体的View给前端控制器。
    4. DispatcherServlet对View进行渲染，也就是将模型数据填充到视图中，然后响应给用户。

优势: 使用了前端控制器(DispatcherServlet)这一组件，会使各个功能模块解耦。

组件
    * DispatcherServlet：前端控制器  
    * HandlerMapping：处理器映射器  
    * Handler：处理器  
    * HandlAdapter：处理器适配器  
    * ViewResolver：视图解析器  
    * View：视图  

    在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view。

Model(接口)和ModelAndView之间的区别:
    ModelAndView需要分别设置数据和视图
        modelAndView.addObject("item", item);
        modelAndView.setViewName("itemEdit");
    Model只需要设置数据, 然后以字符串形式返回视图即可.
        model.addAttribute("item", item);
        return "itemEdit";

=============

mybatis

1. mybatis:
    sqlMapConfig.xml，是mybatis的全局配置文件，配置了数据源、事务管理.
    mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。需要在sqlMapConfig.xml中加载。
    
    通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂,由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行

    - mybatis底层自定义了Executor执行器接口,用来操作数据库;
    - Mapped Statement是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
    - Excutor通过Mapper Statement对象实现输入参数/输出结果与java对象的映射.
    
4. #{}和${}
    #{} 参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。会自动为其中的值添加’’，其中的值可以任意写，比如写成v
        #{}可以有效防止sql注入
        自动进行java类型和jdbc类型转换
    ${} 字符串拼接，静态文本替换。不会自动为其中的值添加’’，而且其中的值必须写成value
        不进行jdbc类型转换
    Select * from user where id = #{v}
    Select * from user where username like “%${value}%”

6. mybatis和hibernate的区别
    Mybatis不完全是一个ORM框架，需要自己编写Sql语句。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。

    Mybatis可以编写原生态sql，可严格控制sql执行性能，灵活度高，但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。

8. Mapper接口开发 --- 取代传统的Dao开发模式
    1、  Mapper.xml文件中的namespace与mapper接口的类路径相同。
    2、  Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 
    3、  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同
    4、  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同

    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。

    Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
