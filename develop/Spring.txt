public interface BeanFactory  
{  
    public Object getBean(String id);  
}  

public class ClassPathXmlApplicationContext implements BeanFactory  
{  
    //定义一个filePath变量  
    private String filePath;  
      
    //首先定义Map 目的来存放生产的对象  
    Map<String, Object> map = new HashMap<String, Object>();  
      
    public ClassPathXmlApplicationContext(String filePath)  
    {  
        //获取配置文件路径  
        this.filePath = filePath;  
        //初始化  
        try  
        {  
            this.readFile();  
        }  
        catch (Exception e)  
        {  
            e.printStackTrace();  
        }  
    }  
      
    private void readFile()  
        throws DocumentException, InstantiationException, IllegalAccessException, ClassNotFoundException  
    {  
        //接下来，用dom4j来解析，，，dom4j下载地址：http://sourceforge.net/projects/dom4j  
        SAXReader reader = new SAXReader();  
        //获取根节点  
        Document document = reader.read(this.getClass().getClassLoader().getResourceAsStream(filePath));  
        //获取bean所有的元素  
        List<Element> list = document.selectNodes("/beans/bean");  
        for (int i = 0; i < list.size(); i++)  
        {  
            //获取bean的id  
            String id = list.get(i).attributeValue("id");  
            //获取bean的class也就是类的路径  
            String classpath = list.get(i).attributeValue("class");  
            //利用反射获取对象  有三种方式，，，我们通过类的全名+包名来生成  
            Object object = Class.forName(classpath).newInstance();  
              
            //放到我们定义的map里 key =id ,vlaue =获取的对象，为下面getBean（）取对象提供条件  
            map.put(id, object);  
        }  
    }  
      
    @Override  
    public Object getBean(String id)  
    {  
        //这里根据id来获取对于的对象既可  
        return map.get(id);  
    }  
      
}  

ApplicationContext和BeanFactory在获取对象的区别:
    BeanFactory factory = new XmlBeanFactory(new ClassPathResource("com/hsp/ioc/beans.xml"));
    - applicationContext: 只要我们实例化容器，那么所有的对象都会被实例化(前提是将bean配置成单例模式)
    - BeanFactory: 首先实例化该容器，容器中的对象是否立即实例化，根据配置文件的配置来进行配置。如果容器的bean配置的是不被立即实例化，那只有执行getBean去获取某个bean的时候，容器才会将对象实例化。
    - 使用applicationContext的好处就是：所有的对象都可以预加载，缺点就是消耗服务器的内存；而使用BeanFactory的话，好处是节约内存，缺点则是速度会相对来说慢一些。而且有可能会出现空指针异常的错误。而且通过bean工厂创建的bean生命周期会简单一些。
系统中通过引入实现了IOC模式的IOC容器, 即可由IOC容器来管理对象的生命周期, 依赖关系等.

Spring的IOC动态注入
    利用java里的类反射，根据在XML中定义的类名, 在运行时动态创建和生成对象,以及创建对象之间的依赖
    Spring就是在运行时，根据xml的配置文件来动态的创建对象，和调用对象里的方法的。

1.BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范,比如根据bean的名字，获取在IOC容器中得到bean实例
2. 具体的IOC容器实现，spring提供了许多IOC容器的实现。 
    XmlBeanFactory，ClasspathXmlApplicationContext
3. Bean对象在Spring实现中是以BeanDefinition来描述的

Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入

spring整合web项目
    启动时创建ServletContext对象, 监听器监听到之后, 加载spring的配置文件, 创建其中的对象, 放在ServletContext中.

Spring源码之IoC容器的加载

- IoC容器的初始化包括三个过程，BeanDefinition的Resource的定位、载入和注册。

- 1. Resource的定位。指BeanDefinition的资源定位，通过ResourceLoader接口中的getResource方法完成。（对各种形式的BeanDefinition提供统一的接口）

- 2. BeanDefinition的载入。这个载入过程是把用户定义好的Bean表示成IOC容器内部的数据结构，而这个容器内部的数据结构就是BeanDefinition。BeanDefinition实际上就是POJO对象在IOC容器中的抽象，通过这个BeanDefinition定义的数据结构，使IOC容器能够方便地对POJO对象也就是Bean进行管理。

- 3. 向IOC容器注册BeanDefinition。通过调用BeanDefinitionRegistry接口的实现来完成。通过分析，在IOC容器内部将BeanDefinition注入到一个HashMap中去，IOC容器就是通过这个HashMap来持有这些BeanDefinition数据的

- 注意，在IOC设计中，Bean定义的载入和依赖注入是两个独立的过程。依赖注入一般发生在应用第一次通过getBean向容器索取Bean的时候。但可以通过设置<bean lazyinit="true" />来配置。


核心
    控制反转（IoC）和切面编程（AOP）  
    依赖注入(DI)和控制反转(IOC)在spring环境下是等同的概念。控制反转是通过依赖注入实现的。

spring容器:
    创建对象
    管理依赖
    管理生命周期, 实现丰富的逻辑

依赖注入指容器负责创建对象和维护对象之间的依赖关系，而不是靠对象自己。依赖注入的主要目的是解耦，体现一种“组合”的理念。希望一个类具备某个功能，组合另外一个具有这样功能的类，比继承一个具有此功能的父类更好。

IoC负责创建Bean，并通过容器将功能类Bean注入到需要的Bean中。有xml配置，注解配置，Java配置。这些都被称为配置元数据。

优点
1. 方便解耦，简化开发（spring是一个大容器，负责创建bean，维护bean之间的依赖）
2. AOP支持（面向切面编程，权限拦截，运行监控）
3. 事务的支持
4. 方便单元测试
5. 继承各种优秀框架
6. 对JdbcTemplate等JAVAEE的API进行封装，简化使用。

spring的核心容器包括，Beans（管理bean），Core，Context，ExpressLanguage（spring的EL表达式）

依赖注入（DI）
is a ：是一个，继承。  
has a：有一个，成员变量，依赖。

class B {
    private A a;   //B类依赖A类
}

依赖：一个对象需要使用另一个对象  
注入：通过setter方法进行另一个对象实例设置。

class BookServiceImpl{
    //之前开发：接口 = 实现类  （service和dao耦合）
    //private BookDao bookDao = new BookDaoImpl();
    
    //spring之后 （解耦：service实现类使用dao接口，不知道dao接口具体的实现类）
    private BookDao bookDao;
    BookDao的setter方法
}


## AOP
#### 底层原理（BeanPostProcessor）
spring 提供一种机制，只要我们写的类实现BeanPostProcessor接口，并将实现类提供给spring容器(<bean class=""> 不需要写id)，spring容器将自动在初始化方法(init)前执行before()，在初始化方法后执行after() 

目的是修改生成的bean对象，创建代理对象，是AOP的底层。
> 这里创建的代理对象，可以在before方法中返回代理对象，也可以在after方法中返回代理对象。  

public class MyBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    	System.out.println("前方法 ： " + beanName);
    	return bean;
    }
    
    @Override
    public Object postProcessAfterInitialization(final Object bean, String beanName) throws BeansException {
    	System.out.println("后方法 ： " + beanName);
    	// bean 目标对象
    	// 生成 jdk 代理
    	return Proxy.newProxyInstance(
            MyBeanPostProcessor.class.getClassLoader(), 
            bean.getClass().getInterfaces(), 
            new InvocationHandler(){
            	@Override
            	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    System.out.println("开启事务");
            		
                    //执行目标方法
                    Object obj = method.invoke(bean, args);
                    
                    System.out.println("提交事务");
                    return obj;
            	}
            }
        );
    }
}

#### AOP的概念
1. AOP指面向切面编程。通过预编译方式，或者主要是运行期间的动态代理技术来实现功能。它可以使业务逻辑各部分之间的耦合度降低，提高程序的可重用性。
2. 采取横向抽取机制，取代了传统纵向继承体系重复性代码  
具体指，比如原来要为Service中的add和delete两个方法添加事务的操作，而且不能修改原先的代码。那么我们只能另外写一个类A来继承Service类，然后分别在add和delete方法的前后，加事务开启和事务提交。  
但是，如果使用AOP，我们就可以直接写一个A类，里面是开启和提交事务的方法，然后把A类和Service全部交给Spring，让它为我们产生代理对象。  
3. 经典应用：事务管理、性能监视、安全检查、缓存 、日志等。  

第一种情况，有接口情况，使用动态代理创建接口实现类代理对象  
第二种情况，没有接口情况，使用cglib代理创建类的子类代理对象

#### 术语
    Joinpoint(连接点): 指类里面可以被增强的方法。  
    Pointcut(切入点)：指我们要进行拦截增强的那些连接点。
    Advice(通知/增强)：指对切入点所做的事情。通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)  
    Aspect(切面): 是切入点和通知的结合。 
    Weaving(织入)：把增强advice应用到目标对象target来创建新的代理对象proxy的过程。
    目标类：需要被代理的类。  
    代理类：Proxy  


JDK动态代理 对“装饰者”设计模式 简化。使用前提：必须有接口
    1.目标类：接口 + 实现类
    2.切面类：用于存通知 MyAspect
    3.工厂类：编写工厂生成代理
    4.测试

//目标类
public interface UserService {
    public void addUser();
    public void updateUser();
    public void deleteUser();
}

//切面类
public class MyAspect {
    public void before(){
        System.out.println("鸡首");
    }
    
    public void after(){
        System.out.println("牛后");
    }
}

//工厂类
public class MyBeanFactory {
    
    public static UserService createService(){
        //1 目标类
        final UserService userService = new UserServiceImpl();
        //2 切面类
        final MyAspect myAspect = new MyAspect();
        
        /* 
         *  3 生成代理类：将目标类（切入点）和 切面类（通知） 结合 --> 切面
         *  Proxy.newProxyInstance
         *      参数1：loader，类加载器，动态代理类是在运行时创建，任何类都需要类加载器将其加载到内存。
         *          一般情况：当前类.class.getClassLoader();
         *          也可以：目标类的!实例!.getClass().getClassLoader();
         *      参数2：Class[] interfaces 代理类需要实现的所有接口
         *          方式1：目标类实例.getClass().getInterfaces();注意：只能获得自己接口，不能获得父元素接口
         *          方式2：new Class[]{UserService.class}   
         *      参数3：InvocationHandler，这是一个接口，必须进行实现类，一般采用匿名内部
         *          提供 invoke 方法，!代理类的每一个方法执行时，都将调用一次invoke!
         *              参数31：Object proxy ：代理对象
         *              参数32：Method method : 代理对象当前执行的方法的描述对象（反射）
         *                  执行方法名：method.getName()
         *                  执行方法：method.invoke(目标对象，实际参数)
         *              参数33：Object[] args :方法实际参数
         * 
         */
        UserService proxService = (UserService)Proxy.newProxyInstance(
            MyBeanFactory.class.getClassLoader(), 
            userService.getClass().getInterfaces(), 
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    
                    //前执行
                    myAspect.before();
                    
                    //执行目标类的方法，有返回值，也就是addUser的返回值，是null
                    Object obj = method.invoke(userService, args);
                    
                    //后执行
                    myAspect.after();
                    
                    //返回方法的返回值
                    return obj;
                }
            }
        );
        return proxService;
    }
}

//测试类
@Test
public void demo01(){
    UserService userService = MyBeanFactory.createService();
    userService.addUser();
    userService.updateUser();
    userService.deleteUser();
}

=======

cglib代理:
    public class MyBeanFactory {
        public static UserServiceImpl createService(){
            //1 目标类
            final UserServiceImpl userService = new UserServiceImpl();
            //2切面类
            final MyAspect myAspect = new MyAspect();
            
            // 3.代理类 ，采用cglib，底层创建目标类的子类
            //3.1 核心类
            Enhancer enhancer = new Enhancer();
            //3.2 确定父类
            enhancer.setSuperclass(userService.getClass());
            /* 3.3 设置回调函数, MethodInterceptor接口 等效 jdk中的 InvocationHandler接口
             *  intercept() 等效 jdk  invoke()
             *      参数1、参数2、参数3：和invoke一样
             *      参数4：methodProxy 方法的代理
             */
            enhancer.setCallback(new MethodInterceptor() {
                @Override
                public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
                    //前
                    myAspect.before();
                    
                    //执行目标类的方法
                    Object obj = method.invoke(userService, args);
                    //执行代理类的父类（其实就是目标类）中的方法，和上面一行的效果等价，可以不写。
                    methodProxy.invokeSuper(proxy, args);
                    
                    //后
                    myAspect.after();
                    
                    return obj;
                }
            });
            
            //3.4 创建代理
            UserServiceImpl proxService = (UserServiceImpl) enhancer.create();
            
            return proxService;
        }
    }

springmvc执行流程
    1. 每一个请求都会先发给DispatcherServlet，然后由其负责请求的分发，给相应的HandlerMapping处理器映射器，然后根据请求的url，找到对应的处理器，生成处理器对象，返回给DispatcherServlet。
    2. DispatcherServlet通过HandlerAdapter处理器适配器来调用处理器Handler, 它是继DispatcherServlet之后的后端控制器，执行处理器的业务逻辑。执行完成后，将返回ModelAndView对象给处理器适配器，然后处理器适配器再把ModelAndView返回给前端控制器。
    3. DispatcherServlet把ModelAndView传递给ViewResolver视图解析器，解析之后返回具体的View给前端控制器。
    4. DispatcherServlet对View进行渲染，也就是将模型数据填充到视图中，然后响应给用户。

优势: 使用了前端控制器(DispatcherServlet)这一组件，会使各个功能模块解耦。

组件
    * DispatcherServlet：前端控制器  
    * HandlerMapping：处理器映射器  
    * Handler：处理器  
    * HandlAdapter：处理器适配器  
    * ViewResolver：视图解析器  
    * View：视图  

    在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view。

Model(接口)和ModelAndView之间的区别:
    ModelAndView需要分别设置数据和视图
        modelAndView.addObject("item", item);
        modelAndView.setViewName("itemEdit");
    Model只需要设置数据, 然后以字符串形式返回视图即可.
        model.addAttribute("item", item);
        return "itemEdit";

重定向和转发    
    重定向后浏览器地址栏变更为重定向的地址，
    重定向相当于执行了新的request和response，所以之前的请求参数都会丢失
    如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数

    转发后浏览器地址栏还是原来的请求地址，
    转发并没有执行新的request和response，所以之前的请求参数都存在

struts2和springmvc的区别
    1、  springmvc的入口是一个servlet即前端控制器，而struts2入口是一个filter过滤器。  
    2、  springmvc是基于方法开发(一个url对应一个方法)，请求参数传递到方法的形参，可以设计为单例或多例(建议单例)，struts2是基于类开发，传递参数是通过类的属性，只能设计为多例。  
    3、  struts采用值栈存储请求和响应的数据，通过OGNL存取数据，springmvc通过参数解析器是将request请求内容解析，并给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面。Jsp视图解析器默认使用jstl。

=============

mybatis

1. mybatis:
    sqlMapConfig.xml，是mybatis的全局配置文件，配置了数据源、事务管理.
    mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。需要在sqlMapConfig.xml中加载。
    
    通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂,由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行

    - mybatis底层自定义了Executor执行器接口,用来操作数据库;
    - Mapped Statement是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。
    - Excutor通过Mapper Statement对象实现输入参数/输出结果与java对象的映射.
    
4. #{}和${}
    #{} 参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值。会自动为其中的值添加’’，其中的值可以任意写，比如写成v
        #{}可以有效防止sql注入
        自动进行java类型和jdbc类型转换
    ${} 字符串拼接，静态文本替换。不会自动为其中的值添加’’，而且其中的值必须写成value
        不进行jdbc类型转换
    Select * from user where id = #{v}
    Select * from user where username like “%${value}%”

6. mybatis和hibernate的区别
    Mybatis不完全是一个ORM框架，需要自己编写Sql语句。mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。

    Mybatis可以编写原生态sql，可严格控制sql执行性能，灵活度高，但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。

8. Mapper接口开发 --- 取代传统的Dao开发模式
    1、  Mapper.xml文件中的namespace与mapper接口的类路径相同。
    2、  Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 
    3、  Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同
    4、  Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同

    Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。

    Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

    Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。
