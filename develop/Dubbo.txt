rpc
	1）服务消费方（client）调用以本地调用方式调用服务；
	2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
	3）client stub找到服务地址，并将消息发送到服务端；
	4）server stub收到消息后进行解码；
	5）server stub根据解码结果调用本地的服务；
	6）本地服务执行并将结果返回给server stub；
	7）server stub将返回结果打包成消息并发送至消费方；
	8）client stub接收到消息，并进行解码；
	9）服务消费方得到最终结果。

	怎么封装通信细节才能让用户像以本地调用方式调用远程服务呢？对java来说就是使用代理！java代理有两种方式：1） jdk 动态代理；2）字节码生成。尽管字节码生成方式实现的代理更为强大和高效，但代码不易维护，大部分公司实现RPC框架时还是选择动态代理方式。

	我们需要实现RPCProxyClient代理类，代理类的invoke方法中封装了与远端服务通信的细节，消费方首先从RPCProxyClient获得服务提供方的接口，当执行helloWorldService.sayHello(“test”)方法时就会调用invoke方法。

	确定消息数据结构
		1）接口名称
		2）方法名
		3）参数类型&参数值
		4）超时时间
		5）requestID，标识唯一请求id
		同理服务端返回的消息结构一般包括以下内容。
			1）返回值
			2）状态code
			3）requestID
	序列化
		通用性, 性能, 可扩展性protobuf
	通信
		消息数据结构被序列化为二进制串后，下一步就要进行网络通信了。目前有两种IO通信模型：1）BIO；2）NIO。一般RPC框架需要支持这两种IO模型，

	1）client线程每次通过socket调用一次远程接口前，生成一个唯一的ID，即requestID（requestID必需保证在一个Socket连接里面是唯一的），一般常常使用AtomicLong从0开始累计数字生成唯一ID；

	2）将处理结果的回调对象callback，存放到全局ConcurrentHashMap里面put(requestID, callback)；

	3）当线程调用channel.writeAndFlush()发送消息后，紧接着执行callback的get()方法试图获取远程返回的结果。在get()内部，则使用synchronized获取回调对象callback的锁，再先检测是否已经获取到结果，如果没有，然后调用callback的wait()方法，释放callback上的锁，让当前线程处于等待状态。

	4）服务端接收到请求并处理后，将response结果（此结果中包含了前面的requestID）发送给客户端，客户端socket连接上专门监听消息的线程收到消息，分析结果，取到requestID，再从前面的ConcurrentHashMap里面get(requestID)，从而找到callback对象，再用synchronized获取callback上的锁，将方法调用结果设置到callback对象里，再调用callback.notifyAll()唤醒前面处于等待状态的线程。

	zookeeper可以充当一个服务注册表（Service Registry），让多个服务提供者形成一个集群，让服务消费者通过服务注册表获取具体的服务访问地址（ip+端口）去访问具体的服务提供者。

	zookeeper提供了“心跳检测”功能，它会定时向各个服务提供者发送一个请求（实际上建立的是一个 socket 长连接），如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除，

	更为重要的是zookeeper 与生俱来的容错容灾能力（比如leader选举），可以确保服务注册表的高可用性。

restful: 是rpc的一种
    查询 /user/query?name=tom         GET         /user?name=tome     GET
    详情 /user/getInfo?id=1           GET         /user/1             GET
    创建 /user/create?name=tome       POST        /user               POST
    修改 /user/update?id=1&name=jerry POST        /user/1             PUT
    删除 /user/delete?id=1            GET         /user/1             DELETE

    1.用url描述资源
    2.用HTTP方法描述行为，使用HTTP状态码表示不同的结果
    3.用json交互数据
    4.只是一种风格，不是强制的标准

	不是所有的方法都适合用restful接口

因为要把所有的controller方法的参数都写在url中, 这时候如果参数不全部传, 会造成表意不明, 无法映射到某一个确定的方法

采用SOA架构，使用Zookeeper作为注册中心，子系统之间通过Dubbo通信、调用服务；

	服务层和表现层是不同的工程，所以需要系统之间的通信。
		注意：pojo类都要实现序列化接口，因为要在网络中传输！

	使用dubbo
		rpc(远程过程调用,直接调用方法)协议进行远程调用，使用socket通信。
		传输效率高，并且可以统计出系统之间的调用关系、调用次数。

	dubbo：分布式服务架构的治理系统，用来进行资源调度，使得所有的服务有统一的入口
		五部分组成：
			Provider: 暴露服务的服务提供方。
			Consumer: 调用远程服务的服务消费方。
			Registry: 服务注册与发现的注册中心。
			Monitor: 统计服务的调用次调和调用时间的监控中心。
			Container: 服务运行容器。

		原理：
			0. 容器负责启动，加载，运行服务提供者。
			1. 服务提供者在启动时，向注册中心注册自己提供的服务。
			2. 服务消费者在启动时，向注册中心订阅自己所需的服务。
			3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
			4. 服务消费者，从提供者地址列表中基于软负载均衡算法，选一台提供者调用，如果调用失败，再选另一台。
			5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

	zookeeper: 是dubbo中的注册中心（适合做集群管理中心）奇数个节点
		注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小

Dubbo架构的主要质量属性
	1、连通性
		①注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。
		②监控中心服务统计各服务调用次数、调用时间等，统计先在内存汇总后每一分钟发送到监控中心服务器，并以报表展示。
		③服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者 ，同事汇报调用时间到监控中心。
		④注册中心、服务提供者、服务消费者三者之间均为长连接，监控中心除外。
		⑤注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者。
		⑥注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。
		⑦注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。

	2、健壮性
		①监控中心宕机不影响使用，只是丢失部分采样数据。
		②数据库宕机后，注册中心仍能通过缓存提供服务列表查询，但不能注册新的服务。
		③注册中心对等集群，任意一台宕机后，将自动切换到另一台。
		④注册中心全部宕机后，服务提供者和服务消费者仍能通过本地缓存通信。
		⑥服务提供者无状态，任意一台宕机后不影响使用。
		⑦服务提供者全部宕机后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复。
