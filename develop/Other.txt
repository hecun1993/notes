maven
    编译 测试 运行 需要不同的classpath

    compile：编译依赖范围。如果没有指定，默认使用该依赖范围。
        使用此依赖范围时，对于编译、测试、运行都有效。例如：spring-core，编译、测试、运行时都需要使用该依赖。
    test：测试依赖范围。只对测试classpath有效。
        例如：JUnit，它只在编译测试代码以及运行测试的时候才需要，编译和运行classpath时无法使用此依赖。
    provided：已提供依赖范围。对于编译和测试时有效，但在运行时无效。
        例如：servlet-api，编译和测试项目的时候需要该依赖，但运行时，由于容器已经提供，就不需要Maven重复的引入。
    runtime：运行时依赖。编译时无效，对于测试和运行有效。
        例如：JDBC驱动实现，编译时只需要JDK提供的JDBC接口，只有在执行测试和运行时才需要实现上述接口的具体JDBC驱动。
    system：系统依赖范围。同provided。
        使用该依赖时必须通过systemPath元素显式地指定依赖文件路径。主要用于依赖本地的、且Maven仓库之外的类库文件。

当我们依赖一个a.jar时，如果a.jar依赖b.jar，那么只需要早pom中声明对a.jar的依赖即可，b.jar会被Maven自动加载进来。

Guava Cache
    是一个全内存的本地缓存实现，它提供了线程安全的实现机制。
	注意: 缓存中存放的数据总量不会超出内存容量。

	令牌桶和漏桶的机制
        RateLimiter.create() 
        RateLimiter.acquire()

	1. 规定每秒可以发requestNum个请求
    	RateLimiter rateLimiter = RateLimiter.create(requestNum, 1, TimeUnit.SECONDS);
	2. 进行循环
	    while (flag) {
            //执行本句之后,saveRecord才可以执行,相当于控制速度(每秒只能执行requestNum次)
            rateLimiter.acquire();
            //业务逻辑
        }

    //定义本地缓存localCache
    private static LoadingCache<String, String> localCache = CacheBuilder.newBuilder()
            .initialCapacity(1000)
            .maximumSize(10000)
            .expireAfterAccess(12, TimeUnit.HOURS)
            .build(new CacheLoader<String, String>() {
                //当调用get取guava缓存中的值时,如果键名key没有对应的键值,就调用这个方法进行返回值
                //这里是说,如果没有值的话,就返回"null"这个字符串
                @Override
                public String load(String s) throws Exception {
                    return "null";
                }
            });

    public static String getKey(String key) {
        String value;
        try {
            value = localCache.get(key);
            //如果执行了if,也就是返回了null,就说明,之前没有向缓存中添加键值对,现在却要取值,所以会返回"null"这个字符串
            //最终的结果是,从缓存中取值,获得了null
            if ("null".equals(value)) {
                return null;
            }
            return value;
        } catch (Exception e) {
            logger.error("localCache get error", e);
        }
        return null;
    }

docker
	1. 解决了运行环境不一致的问题
	2. 解决了某一程序内存占满导致别的程序无法正常运行，docker首先在启动时就限定某一程序锁使用的空间。这就是隔离性
	3. 解决了服务器扩容问题，弹性伸缩，快速扩展

	docker镜像，就是一个文件系统

solr使用zookeeper作分布式管理，支持多种数据格式，json，xml，csv。
elasticsearch自带分布式管理功能，只支持json，提供restful接口，只提供核心功能，可扩展。实时搜索效率更高

QPS：每秒请求或查询的数量，每秒响应的请求数（http响应）

ab：模拟并发请求100次，总共请求5000次
ab -c 100 -n 5000 www.baidu.com

“阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。

1.同步与异步

所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用得到返回结果, 这个调用才结束.
换句话说，就是由*调用者*主动等待*调用*的结果。

而异步则是，*调用*在发出之后，就直接结束了，所以此时没有返回结果。
换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，
如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

2. 阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，
你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，
如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。

在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

restful: 是rpc的一种
    查询 /user/query?name=tom         GET         /user?name=tome     GET
    详情 /user/getInfo?id=1           GET         /user/1             GET
    创建 /user/create?name=tome       POST        /user               POST
    修改 /user/update?id=1&name=jerry POST        /user/1             PUT
    删除 /user/delete?id=1            GET         /user/1             DELETE

    1.用url描述资源
    2.用HTTP方法描述行为，使用HTTP状态码表示不同的结果
    3.用json交互数据
    4.只是一种风格，不是强制的标准

solr
    要执行全文搜索, 必须先把数据导入solr库中, 但事先必须有相应的域
    在创建对应的业务域之前，需要制定中文分析器
        在schema.xml中配置FieldType，指定使用IKAnalyzer

    查询：
        连接SolrServer
        创建SolrQuery对象
        SolrQuery中添加查询条件
        执行查询。得到一个Response对象
        从中得到查询结果
    添加文档
        创建一个文档对象SolrInputDocument
        向文档中添加域。必须有id域
        把文档添加到索引库中
        提交

* 全文检索
    结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。  
    非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等。

    对非结构化数据的搜索：
        顺序扫描法（grep 查找文件）
        全文搜索（将非结构化数据的一部分转为结构化数据，然后提取索引）
            建文本库
            建立索引
            执行搜索
            过滤结果

先建立索引，再对索引进行搜索的过程就叫全文检索

1）创建文档对象：为每个文件对应的创建一个Document对象。把文件的属性都保存到document对象中。需要为每个属性创建一个field（在lucene中叫做域），把field添加到文档对象中。每个document都有一个唯一的编号。

2）分析文档：针对document中的域进行分析，例如分析文件名、文件内容两个域。先把文件内容域中的字符串根据空格进行分词，把单词进行统一转换成小写。把没有意义的单词叫做停用词。把停用词从词汇列表中去掉。去掉标点符号。最终得到一个关键词列表。每个关键词叫做一个Term。Term中包含关键词及其所在的域，不同的域中相当的单词是不同的term。

3）创建索引：索引：为了提高查询速度的一个数据结构。在关键词列表上创建一个索引；把索引和文档对象写入索引库，并记录关键词和文档对象的对应关系。


