spring security基本原理:
	1. 一般, 请求和响应是在一个线程中完成的
    2. 请求 -> UsernamePasswordAuthenticationFilter(表单登录) -> BasicAuthenticationFilter(原始登录) -> ... -> ExceptionTranslationFilter(捕获后一个拦截器产生的异常, 决定后续的步骤) -> FilterSecurityInterceptor(根据配置查看这个用户需要经过哪些验证, 看session中是否有用户信息, 有则可以访问rest api, 否则就抛出异常) -> rest api

	1. 登录请求发来后, 首先来到UsernamePasswordAuthenticationFilter(是过滤器链上的一个过滤器, 负责处理登录请求).
	2. 然后用拿到的登录名和密码, 构建一个UsernamePasswordAuthenticationToken的对象, 它是Authentication接口的实现. 然后把请求的相关信息也放在UsernamePasswordAuthenticationToken对象中
	3. 使用AuthenticationManager,这个类本身不包含认证的逻辑,它的作用是用来收集和管理一组AuthenticationProvider(不同的登录方式, 认证逻辑不同). 首先拿到一组AuthenticationProviders, 然后for循环, 调用supports方法判断是否支持传入的Authentication的类型.
		return this.getAuthenticationManager().authenticate(usernamePasswordAuthenticationToken);
	4. 找出Provider之后, 执行验证. 过程中调用提供的UserDetailsService的实现, 根据用户名获得用户信息UserDetails. 然后进行预检查,密码检查和后检查. 如果检查都通过, 则重新创建UsernamePasswordAuthenticationToken对象, 把权限信息设置进去.
	5. 登录成功, 调用onAuthenticationSuccess方法, 登录成功的处理器. 

认证结果如何在多个请求间共享:request
	1. 最初的想法: 放在session中.
	2. 把认证成功后构建的UsernamePasswordAuthenticationToken对象封装在SecurityContext中, 然后放在SecirutyContextHolder中.
	3. SecirutyContextHolder是ThreadLocal的一个封装. 它是与线程绑定的map. 在同一个线程中, 这个方法里放的变量, 另外一个方法中可以读出. 可以理解为线程级别的变量.
	4. SecurityContextPersistenceFilter在整个过滤器链的最前面.
	作用是检查session中是否有SecurityContext, 如果有, 就拿到线程变量中. 在返回时, 如果有, 就放到session中.
		SecurityContextHolder.getContext().getAuthentication();	

OAuth协议(授权协议)存在的目的:
    让第三方应用可以在不知道用户的用户名密码的情况下, 访问用户存在应用服务器上的(自拍)数据

当(自拍)数据变成了用户信息就变成了Spring social框架:
    Spring social: 把下面的流程封装到了SocialAuthenticationFilter中, 当请求来时, 在这个过滤器里实现了第三方登陆

步骤:
	0. 用户访问client
	1. 将用户导向认证服务器(访问服务器的url, 与第三步的url是一样的)
	2. 用户同意授权
	3. 服务提供商携带授权码返回client(返回的url地址就是回调地址, 在申请qq登录时, 需要填写一个回调域)
	4. client向服务提供商申请令牌
	5. 服务提供商发放令牌
	6. client拿着令牌向服务提供商获取用户信息
	7. 与服务提供商无关, client根据用户信息, 构建Authentication, 并放入SecurityContext中. 实际上就是完成了登录

	综述: 
		1. 开发ServiceProvider, 需要getUserInfo()的Api类和OAuth2Template(封装前五步)
		2. 用ConnectionFactory创建Connection类, 来封装社交登录后获得的用户信息, 
		3. 期间需要调用ApiAdaptor,把不同应用在第六步获得的数据结构不同的用户信息适配转化成相同的Connection类封装用户信息, 然后存在数据库UserConnection表中
		4. 构建出Authentication对象, 实现登录.

Spring social框架: 封装的是client的行为
Spring security OAuth框架: 封装的是服务提供商的行为, 来发令牌等
    -- 认证服务器(通过4种标准授权模式确认用户身份和权限(提供了默认实现),或者使自定义的认证方式(手机号, 社交账号等), 然后调用Token生成机制发给client,来实现Token的生成和存储(提供了默认的实现))
    -- 资源服务器(保护rest服务, 做法是在spring security过滤器链上加了一个OAuth2AuthenticationProcessingFilter, 作用是从请求中拿出token, 根据token的存储策略, 根据Token找到用户信息, 进行判断, 然后访问rest服务)

JWT(json web token)
    自包含: 令牌中包含有意义信息, 不需要到数据库等中读取令牌拿到有意义的信息
    密签: 虽然大家都看得到JWT, 所以不要放敏感信息, 但是发出的令牌可以签名, 防止篡改
    可扩展: 有意义的信息是可以扩展的		

1. 微信小程序支付过程:
	1. 当我们的服务器返回给客户端订单创建成功之后, 小程序会调用服务器的支付接口
	2. 服务器的支付接口会生成一个预订单, 这个预订单的唯一标识, 比如用户的openid, 或者订单号, 将作为参数, 请求微信服务器
	3. 微信服务器会返回一些支付参数
	4. 服务器把这些支付参数返回给小程序, 小程序携带支付参数, 自己访问微信服务器发起支付
	5. 微信服务器会立刻通知小程序是否支付成功
	6. 微信服务器还会[异步的不断的]通知服务器支付结果(成功/失败), 直到服务器发送给微信一个结果通知, 说我已经收到支付结果了, 然后微信服务器才不返回支付结果给服务器.

* 在restful风格的编程中，不存在登录的概念。所有的登录都是依靠令牌（token）来实现的。
* 登录 == 用户去拿令牌（token）
* 用户每次访问某一个api，都要携带之前获取到的令牌，来让服务器判断，它是否有权限调用这个接口。

* 小程序会为每一个用户生成一个code，然后携带code访问服务器的getToken接口。
* getToken接口携带code，访问微信服务器，微信服务器会返回openid，也就是身份的唯一标示。我们需要把openid存在数据库中。
* 我们需要把openid传给客户端，让它每次访问接口时，都携带openid。
* 但是openid不建议传给客户端（机密数据，不能设置过期时间），所以，我们会生成令牌Token，客户端每次访问时携带这个令牌，每一个Token对应一个openid，从而可以找到openid了。
* 然后把Token返回给客户端，同时给Token设置过期时间。
* 要把openid存在数据库，但令牌Token可以存在缓存中，我们只要验证Token是否合法即可，加快访问速度。
